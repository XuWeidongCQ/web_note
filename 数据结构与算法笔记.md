# 一、单向链表

* 在JS中使用多层嵌套的对象来表示链表

* 首先需要一个节点构造函数，来表示链表中的一个元素

* ```js
  class Node {
      constructor(element){
          this.element = element;
          this.next = undefined
      }
  }
  ```

* 其次需要一个链表的构造函数

* ```js
  class LinkList {
      constructor(){
          this.count = 0 //表示链表中元素的个数
          this.head = undefined //指向链表的头部
      };
  }
  ```

* 其中一个指向链表头部的属性是必须的，用于后续进行遍历

* 也可以增加一个属性，用于表示链表的长度，方便后续取出最后一个元素

## 1.1 链表的遍历

* 链表的遍历需要使用一个指针，无限循环直到该指针的下一个元素为undefined为止，首先初始化该指针指向链表的头部

* ```js
  let cur = this.head
  while(cur.next !== undefined){ //遍历到链表的尾部，使得cur指向链表的最后一个元素
    cur.element //cur.element为当前节点的值，可以在这里做一点操作，但是这里取不到最后一个元素
    cur = cur.next
  }
  cur.element //补充最后一个元素
  ```

## 1.2 获取特定位置处的元素

* 初始化一个指针指向链表的头部，然后循环直到该指针指向特定位置的前一个元素位置

```js
getElementAt(index){
  if(index >= 0 && index < this.count){//保证输入的index合法
    let cur = this.head //一个指针指向链表头部
    for(let i=0;i < index && cur !== undefined;i++){//让指针一直遍历到要获取的元素
      cur = cur.next
    }
    return cur
  }
  return undefined
};
```

* 中间的遍历也可以这样写

```js
 let pointer = 0
 while(count <= index){
   if(count === index){
     return cur
   }
   pointer++
   cur = cur.next
 }
```

## 1.3 在链表的任意位置插入元素

* 头部插入单独处理

* 其次，取出要插入位置的前一个元素

* 取出被插入的元素

* 让要插入元素的下一个节点指向被插入的元素

* 让插入位置的前一个元素的下一个节点指向要插入父元素即可

* ```js
  insert(element,index){
    if(index >= 0 && index <= this.count){
      const node = new Node(element);
      if(index === 0){ //在头部插入
        const cur = this.head
        node.next = cur; //将这个插入节点的后续节点指向原来的头部
        this.head = node; //同时头部指向新的
      } else {
        const pervious = this.getElementAt(index-1); //一个指针指向待插入位置的前一个元素
        const cur = pervious.next;//一个指针指向插入位置的元素
        node.next = cur;
        pervious.next = node;
      }
      this.count ++;
      return true
    }
    return false
  };
  ```

## 1.4 统计链表中元素的个数

```js
getSize(){
  let cur = this.head;
  if(cur === null){
    return 0
  }
  let count = 1; //初始化要为1才行
  while(cur.next !== null){
    count++
    cur = cur.next
  }
  return count
}
```

## 1.5 链表和数组的相互转换

* 有些时候将链表转换为数组可以更方便进行处理
* 但是这样会浪费额外的空间

```js
//输入一个链表
const toArr = function(list){
  let pCur = list;
  let arr = [];
  while(pCur){
    arr.push(pCur.val)
    pCur = pCur.next
  }
  return arr
}

//输入一个数组
const toList = function(arr){
  let len = arr.length;
  let node;
  if(len < 1){return null};
  //初始化链表
  let head = new ListNode(arr[0])
  let pCur = head;
  for(let i=1;i<len;i++){
    node = new ListNode(arr[i])
    pCur.next = node
    pCur = pCur.next
  }
  return head
}
```

# 二、回溯算法

* 回溯算法就是纯暴力穷举，复杂度一般都很高，运行时间较长
* 动态是回溯算法的最优情况
* 所以一般不用于找到问题的所有解，找到满足条件的一个解即可
* 回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作
* 在树上的每一个节点都有一个已经选择的路径和将要做出的下一步选择
* 这种算法一般是递归的



* 可以把回溯函数的输入参数看做是解空间树的节点的属性,问题的答案和递归终止条件也必须在输入参数中

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件: //这是函数的结束条件，这里写解是否满足条件
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```



* 如果只需要找到一个答案只需要在结束条件的时候返回true

```python
def backtrack(路径, 选择列表):
    if 满足结束条件: //这是函数的结束条件，这里写解是否满足条件
        result.add(路径)
        return true

    for 选择 in 选择列表:
        做选择
        if(backtrack(路径, 选择列表))
        		return true
        撤销选择
    return false //如果所有情况都尝试完了还没有满足条件，就只能返回false
```

## 2.1 模板(排列组合算法)

* 这是一个计算无重复数字的所有排列的模板

```js
//selectedPath 传入空数组
//rest 每一步可以选择的列表，这里是需要进行排列的所有数据组成的数组

const backTrack = function(selectedPath,rest,callback){
    if(rest.length === 0){
        if(callback){
            callback(selectedPath.slice(0)) //深复制
        }
        return
    }
    for(let i=0;i<rest.length;i++){
        const chose = rest.splice(i,1)[0]
        selectedPath.push(chose)

        backTrack(selectedPath,rest,callback)

        selectedPath.pop()
        rest.splice(i,0,chose)
    }
}
```

## 2.2 模板(二叉树从根到叶子的每一条路径算法)

```js
//path 默认需要传入根节点的值
//node 传入树

function dfs(stack,node){
    stack.push(node.val)
    if(node.left === null && node.right === null){
        console.log(stack)
        return
    }
    if(node.left){
        dfs(stack,node.left)
        stack.pop()
    }
    if(node.right){
        dfs(stack,node.right)
        stack.pop()
    }

}
```



# 三、广度优先遍历BFS

* 该算法可以针对图
* 可以把树看成为有向的图
* 还有一个特点是二叉树的子节点最大为2,这可以提前知道



# 四、排序

## 4.1 时间复杂度

* O(1) 这种复杂度无论数据规模n如何增长，计算时间是不变的
* O(n) 线性复杂度，随着数据规模n的增长，计算时间也会随着n线性增长 例如:线性搜索
* O(logn) 对数复杂度，随着问题规模n的增长，计算时间也会随着n对数级增长 例如：二分搜索
* O(nlogn) 线性对数复杂度，随着数据规模n的增长，计算时间也会随着n呈线性对数级增长 例如:归并排序
* O(n²) 典型情况是当存在双重循环的时候 例如:冒泡排序

![image-20200701120616547](../../AppData/Roaming/Typora/typora-user-images/image-20200701120616547.png)

## 4.2 冒泡排序

* 有多少个元素外层就要循环多少次，每循环一次可以找到一个最大值
* 内部循环是用来进行元素比较的

```js
//冒泡排序--升序
const bubbleSort = function(arr){
    const len = arr.length
    if(len <= 1){return arr}
    let count=0
    while(count < len){
        for(let i=0;i<len-1;i++){
            if(arr[i]>arr[i+1]){
                util.swap(arr,i,i+1)
            }
        }
        count ++
    }
    return arr
}

function bubbleSort(arr){
  for(let i=0;i<arr.length;i++){
    for(let j=0;j<arr.length-1;j++){
      if(arr[j] > arr[j+1]){
        //第一项比第二项大就交换
        [arr[j+1],arr[j]] = [arr[j],arr[j+1]]
      }
    }
  }
  console.log(arr)
}

//选择排序
function selectSort(arr){
  for(let i=0;i<arr.length;i++){
    let min = arr[i]
    let minIdx = i
    for(let j=i+1;j<arr.length;j++){
      if(arr[j] < min){
        min = arr[j]
        minIdx = j
      }
    }
    swap(arr,i,minIdx)
  }
  console.log(arr)
}
//插入排序
function insertSort(arr){
  for(let i=1;i<arr.length;i++){
    let now = arr[i] //即将被拿出来插入的元素
    for(let j=i;j>0;j--){
      if(arr[j-1] > arr[j]){
        swap(arr,j,j-1)
      } else {
        break
      }
    }
  }
  console.log(arr)
}
```

## 4.3 快速排序

* 取出序列中间的值
* 遍历一遍，把序列切割成两半
* 递归调用

```js
//快速排序--这个不好会占用很大的内存空间--但是是这个思想
const quickSort = function(arr){
    const len = arr.length
    if(len <= 1){return arr}//递归基线条件
    const pivotIndex = Math.floor(len/2)
    const pivot = arr.splice(pivotIndex,1)[0] //取出主元，并且把这个元素从原数组中删除
    let less = [],
        greater = []
    for(let i=0;i<arr.length;i++){//注意这里的遍历长度和原来的len不一样，因为去掉了主元
        if(arr[i] >= pivot){
            greater.push(arr[i])
        } else {
            less.push(arr[i])
        }
    }
    return [...quickSort(less),pivot,...quickSort(greater)]//递归
}

//优化
function partition(arr,left,right){//这个函数的目的是找到一个主元的索引，并且按照主元把数组划分好
  let pivot = arr[Math.floor((left + right) / 2)]
  let i=left,j=right
  while(i<=j){
    while(arr[i] < pivot){
      i++
    }
    while(arr[j] > pivot){
      j--
    }
    if(i<=j){
      swap(arr,i,j);
      i++;
      j--
    }
  }
  return i
}

function quickSort(arr,left,right){
  let pivotIndx;
  if(arr.length > 1){
    pivotIndx = partition(arr,left,right)
    if(left < pivotIndx - 1){
      quickSort(arr,left,pivotIndx-1)
    }
    if(pivotIndx < right){
      quickSort(arr,pivotIndx,right)
    } 
  }
  return arr
}

//改进
function quickSort(arr,left=0,right=arr.length-1){
  if(arr.length <= 1){
    return arr
  }
  let l = left;
  let r = right;
  let pivot = arr[Math.floor((left+right) / 2)]
  while(l <= r){
    while(arr[l] < pivot){ //l会依次在大于等于pivot的数字上
      l++
    }
    while(arr[r] > pivot){//r会依次在小于等于pivot的数字上
      r--
    }
    if(l <= r){
      swap(arr,l,r)
      l++
      r--
    }
  }
  if(left < r){ //从left到r是较小的数组
    quickSort(arr,left,r)
  }
  if(l < right){//从l到right是较大的数组
    quickSort(arr,l,right)
  }
  return arr
}
```

## 4.4 计数排序

* 适用于数组的最大值和最小值相差不大的情况

```js
const countingSort = function(arr){
    const maxvalue = Math.max(...arr)
    //初始化一个全是0的计数数组，长度为maxvalue+1，索引为要排序的序列的值，值为出现的次数
    const tempArr = Array(maxvalue + 1).fill(0)
    let sortedIndex = 0
    arr.forEach(val => tempArr[val]++)
    tempArr.forEach((count,idx) => {
        while(count > 0){
            arr[sortedIndex] = idx
            sortedIndex++
            count--
        }
    })
    return arr
}
```

# 五、搜索

## 5.1 二分查找

* 要求元素已排序

```js
//二分搜索--使用循环
function binarySearch(arr,target){
  let low = 0
  let high = arr.length - 1
  while(low <= high){ //这里的等于不能去掉,否则不能搜索数组的第一个元素
    let midIndex = Math.floor((low + high)/ 2)
    if(arr[midIndex] > target){
      high = midIndex - 1
    } else if(arr[midIndex] < target){
      low = midIndex + 1
    } else {
      return midIndex
    }
  }
  return -1
}


//数组中有重复的元素，输出元素的最小索引
function biSearch(arr,target){
  let l = 0
  let r = arr.length - 1
  while(l <= r){
    let mid = Math.floor((l + r) / 2)
    if(arr[mid] < target){
      l = mid + 1
    } else if(arr[mid] > target){
      r = mid - 1
    } else {
      //收缩左边界
      while(arr[mid-1] === target){ 
        mid--
      }
      return mid
    }
  }
  return -1
}


//数组中有重复的元素，输出元素的最大索引
function biSearch(arr,target){
  let l = 0
  let r = arr.length - 1
  while(l <= r){
    let mid = Math.floor((l + r) / 2)
    if(arr[mid] < target){
      l = mid + 1
    } else if(arr[mid] > target){
      r = mid - 1
    } else {
      //收缩右边界
      while(arr[mid+1] === target){ 
        mid++
      }
      return mid
    }
  }
  return -1
}
```

# 六、贪婪算法

* 每一步都选择最优的，不考虑其他的

# 七、动态规划

* 可用于解决最值问题，问题可以分解为一个一个小问题

# # 题目总结

## 1.1 数组

* 连续子序列可以看成从位置i开始的
* 数组能排序就先排序

### 1 53最大子序和 [连续子序列] ++

```
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let len = nums.length
    if(len < 1) return 0
    let maxSum = -Infinity;
    let sum;
    for(let i=0;i<len;i++){
        sum = nums[i]
        maxSum = maxSum > sum ? maxSum : sum
        for(let j=i+1;j<len;j++){
            sum = sum + nums[j]
            maxSum = maxSum > sum ? maxSum : sum
        }
    }
    return maxSum
};

//改进1
var maxSubArray = function(nums) {
    let dp = []
    for(let i=0;i<nums.length;i++){
        if(i===0){
            dp[i] = nums[0]
        } else {
            dp[i] = Math.max(dp[i-1] + nums[i],nums[i])
        }
    }
    return Math.max(...dp)
};

//改进2
var maxSubArray = function(nums) {
    let dp = []
    let res = -Infinity;
    for(let i=0;i<nums.length;i++){
        if(i===0){
            dp[i] = nums[0]
        } else {
            dp[i] = Math.max(dp[i-1] + nums[i],nums[i])
        }
        res = res > dp[i] ? res : dp[i]
    }
    return res
};

//改进3
var maxSubArray = function(nums) {
    let sum;
    let res = -Infinity;
    for(let i=0;i<nums.length;i++){
        if(i===0){
            sum = nums[0]
        } else {
            sum = Math.max(sum + nums[i],nums[i])
        }
        res = res > sum ? res : sum
    }
    return res
};
```

### 2 523连续的子数组和 [连续子序列]

```
给定一个包含 非负数 的数组和一个目标 整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。

输入：[23,2,6,4,7], k = 6
输出：True
解释：[23,2,6,4,7]是大小为 5 的子数组，并且和为 42。
```

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var checkSubarraySum = function(nums, k) {
    let len = nums.length
    let sum = 0
    if(len < 2){
        return false
    }
    for(let i=0;i<len;i++){
        sum = nums[i]
        for(let j=i+1;j<len;j++){
            sum = sum + nums[j]
            if(k === 0){ //k为0
                if(sum === 0){//和也为0的情况
                    return true
                }
            }else{
                if(sum % k === 0){
                    return true
                }
            }
        }
    }
    return false
};
```

###  % 560和为K的子数组 

```
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```

```js
//这是解决子数组问题的暴力法
var subarraySum = function(nums, k) {
    let len = nums.length
    if(len === 0){
        return 0
    }
    let sum = 0
    let ans = 0
    for(let i=0;i<len;i++){
        sum = 0
        for(let j=i;j<len;j++){
            sum = sum + nums[j]
            if(sum === k){
                ans++
            }
        }
    }
    return ans
};
//使用滑动窗口
```

### % 713乘积小于K的子数组 [滑动窗口]

```
输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。

0 < nums.length <= 50000
0 < nums[i] < 1000
0 <= k < 10^6
```

```js
var numSubarrayProductLessThanK = function(nums, k) {
    if(k <= 1) return 0;
    let len = nums.length
    let product = 1;
    let slideArr = [];
    let ans = 0;
    for(let i=0;i<len;i++){
        slideArr.push(nums[i])
        product = product * nums[i]
        while(product >= k){
            product = product / slideArr[0]
            slideArr.shift()
        }
        ans = ans + slideArr.length
    }
    return ans
};

```



### 3 209长度最小的子数组 [连续子序列] ++

```
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。

输入：s = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的连续子数组
```

```js
/**
 * @param {number} s
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(s, nums) {
    let len = nums.length
    let res = Infinity
    let sum = 0
    if(len === 0){ //边界情况1
        return 0
    }
    for(let i=0;i<len;i++){
        sum = nums[i]
        if(sum >= s){//边界情况2 该元素自己就比s大
            return 1
        } else {
            for(let j=i+1;j<len;j++){
                sum = sum + nums[j]
                if(sum >= s){
                    res = res > j-i+1 ? j-i+1 : res //找到最小的长度
                    break
                }
            }
        }
        
    }
    if(res === Infinity){
        return 0
    } else {
        return res
    }
};

//改进1
var minSubArrayLen = function(s, nums) {
    let len = nums.length
    if(len === 0){
        return 0
    }
    let ans = Infinity;
    let start = 0;
    let end = 0;
    let sum = 0;
    while(end <= len - 1){
        sum = sum + nums[end]
        while(sum >= s){
            ans = Math.min(ans,end-start+1)
            sum = sum - nums[start]
            start++
        }
        end++
    }
    return ans === Infinity ? 0 : ans
};
//改进2 滑动窗口
var minSubArrayLen = function(s, nums) {
    let len = nums.length
    if(len === 0){
        return 0
    }
    let slideArr = []
    let sum = 0
    let ans = Infinity
    for(let i=0;i<len;i++){
        slideArr.push(nums[i])
        sum = sum + nums[i]
        while(sum >= s){
            sum = sum - slideArr[0]
            ans = Math.min(ans,slideArr.length)
            slideArr.shift()
        }
    }
    return ans === Infinity ? 0 : ans
};
```

### 4 718最长重复子数组 [ 动态规划]

```
给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3, 2, 1] 。
```

```js
/**
 * @param {number[]} A
 * @param {number[]} B
 * @return {number}
 */
var findLength = function(A, B) {
    let lenA = A.length;
    let lenB = B.length;
    if(lenA === 0 || lenB === 0) return 0 //边界条件1
    let dp = [] //初始化动态规划矩阵
    let maxLength = 0
    for(let i=0;i<lenA;i++){
        dp[i] = []
        for(let j=0;j<lenB;j++){      
            if(A[i] != B[j]) {
                dp[i][j] = 0
            } else {
                if(i === 0 || j===0){ //边界条件2 是否为动态规划矩阵的边缘
                    dp[i][j] = 1
                } else {
                    dp[i][j] = dp[i-1][j-1] + 1 //动态规划递推式（左上方）
                }
            }
            maxLength = maxLength > dp[i][j] ? maxLength : dp[i][j] //每次取最大的长度
        }
    }
    return maxLength
};
```

### 5 跳跃游戏 [贪心算法]++

```
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。

输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```

```js
//每次循环都记录当前位置所能够到达的最远的位置
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
    let len = nums.length
    if(len === 0) return false//边界条件1
    let target = len - 1;
    let posNow = 0 //记录能够到达的最远位置
    for(let i=0;i<len;i++){
        if(posNow >= target) return true //终止条件1 最远位置超过末尾
        if(posNow < i) return false//终止条件2 最远位置落后当前位置
        if(i+nums[i] > posNow){ //贪心选择最远的位置
            posNow = i + nums[i]
        }
    }
    return false
};
```

### 6 盛最多水的容器 [贪心算法 暴力法]

```
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
输入：[1,8,6,2,5,4,8,3,7]
输出：49
```

```js
//暴力法
var maxArea = function(height) {
    let len = height.length;
    let maxWater = 0
    let tempMin = 0
    for(let i=0;i<len;i++){
        for(let j=i+1;j<len;j++){
            tempMin = Math.min(height[i],height[j])
            if(tempMin * (j - i) > maxWater){
                maxWater = tempMin * (j - i)
            }
        }
    }
    return maxWater
};
```

### 7 39组合总和 [递归回溯]

```
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。

输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
```

```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
    let res = []
    function sum(arr){
        let res = 0
        for(let v of arr){
            res = res + v
        }
        return res
    }
    //回溯函数
    function backTrack(selPath,restPath,target){
        if(sum(selPath) >= target){
            if(sum(selPath) === target){
                res.push(selPath.slice(0))
            }
            return
        }
        for(let i=0;i<restPath.length;i++){
            const chose = restPath[i]
            if(selPath[selPath.length - 1] && selPath[selPath.length - 1] > chose){ //减枝
                continue
            }
            selPath.push(chose)//做出选择
            backTrack(selPath,restPath,target)
            selPath.pop()//撤销选择
        }
    }

    backTrack([],candidates,target)
    return res
};
```

### 8 40组合总和II [递归回溯]

```
给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次。
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```

```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
    let res = []
    function sum(arr){
        let res = 0
        for(let v of arr){
            res = res + v
        }
        return res
    }
    //回溯函数
    function backTrack(selPath,restPath,target){
        if(sum(selPath) >= target){
            sum(selPath) === target ? res.push(selPath.slice(0)) : ''
            return
        }
        for(let i=0;i<restPath.length;i++){
            //减枝 以满足条件
            if(restPath[i+1] && restPath[i+1] === restPath[i]){ //减枝 去除重复
                continue
            }
            const chose = restPath.splice(i,1)[0]
            if(chose > target) break; //大减枝 加快运行时间
            if(selPath[selPath.length - 1] && selPath[selPath.length - 1] > chose){ //减枝 去除重复
                restPath.splice(i,0,chose)
                continue
            }
            
            selPath.push(chose)//做出选择
            backTrack(selPath,restPath,target)
            selPath.pop()//撤销选择
            restPath.splice(i,0,chose)
        }
    }
    candidates.sort((a,b) => a - b)
    backTrack([],candidates,target)
    return res
};
```

### 9 48原地旋转矩阵 [找规律]

```
给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

```js
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
    let nRow = matrix.length
    let nCol = matrix.length
    let temp
    for(let i=0;i<nRow;i++){
        for(let j=0;j<=i;j++){
            //将矩阵的元素沿着主对角线交换
            [matrix[i][j],matrix[j][i]] = [matrix[j][i],matrix[i][j]]
        }
    }
    for(let i = 0;i<nRow;i++){
        matrix[i].reverse()
    }
};
```

### 10 54顺时针螺旋打印矩阵 [找规律]

```
给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。
输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]
```

```js
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
    let res = []
    let col=0,row=0
    let nRow = matrix.length
    if( nRow === 0) return [] //边界条件 输入为[]
    let nCol = matrix[0].length
    if( nCol === 0) return [] //边界条件 输入为[[]]

    let turn = nCol === 1 ? 'b' : 'r' //重要:初始化打印方向,矩阵只有一列直接向下打印，否则向右
    let boundRight = nCol - 1
    let boundLeft = 0
    let boundTop = 0
    let boundBottom = nRow - 1
    let totalEle = nRow * nCol
    while(totalEle > 0){
        res.push(matrix[row][col])
        if(turn === 'r') {
            col++ //向右移动一步
            if(col === boundRight){
                boundTop ++ //更新边界
                turn = 'b' //改变方向
            }
        } else if(turn === 'b') {
            row++
            if(row === boundBottom){
                boundRight--
                turn = 'l'
            }
        } else if(turn === 'l'){
            col--
            if(col === boundLeft){
                boundBottom--
                turn = 'u'
            }
        } else if(turn === 'u'){
            row--
            if(row === boundTop){
                boundLeft++
                turn = 'r'
            }
        }
        totalEle--
    }
    return res
};
```

```js
//附：初始化二维矩阵的方法
let res = Array(n).fill(Array(n).fill(0)) //这种会出问题 因为填充的是引用对象

let res = Array(n).fill(0).map(() => Array(n).fill(0)) //这样写正确
//或者适用循环
let res = []
    for(let i=0;i<n;i++){
        res[i] = []
        for(let j=0;j<n;j++){
            res[i][j] = 0
        }
    }
```

### 11 121买卖股票的最佳时机(多笔交易)II  [维护一个状态]

```
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

```js
var maxProfit = function(prices) {
    let profit = 0
    let buyPrice;
    if(prices.length <= 1){
        return profit
    }
    for(let i=0;i<prices.length-1;i++){
       if(prices[i+1] > prices[i]){
           profit = profit + prices[i+1] - prices[i]
       }
    }
    return profit
};
```

### 12 121买卖股票的最佳时机(一笔交易)

```
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
注意：你不能在买入股票前卖出股票
```

```js
var maxProfit = function(prices) {
    let profit = 0
    let minPrice = Infinity;
    if(prices.length <= 1){
        return profit
    }
    for(let i=0;i<prices.length;i++){
       if(prices[i] < minPrice){
           minPrice = prices[i]
       } else if(prices[i] - minPrice > profit){
           profit = prices[i] - minPrice
       }
    }
    return profit
};
```

### 13 152乘积最大子数组 [连续子序列]

```
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function(nums) {
    let len = nums.length
    if(len === 1){return nums[0]} //边界条件
    let nowProd = nums[0]
    let resProd = nums[0]
    for(let i=0;i<len;i++){
        nowProd = nums[i]
        resProd = resProd > nowProd ? resProd : nowProd
        for(let j=i+1;j<len;j++){
            nowProd = nowProd * nums[j]
            resProd = resProd > nowProd ? resProd : nowProd
        }
        
    }
    return resProd
};
```

### 13 寻找峰值 [找规律]

```
峰值元素是指其值大于左右相邻值的元素。
给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。
数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。
你可以假设 nums[-1] = nums[n] = -∞。
输入: nums = [1,2,1,3,5,6,4]
输出: 1 或 5 
解释: 你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
    let len = nums.length
    //重要 初始化两个边界条件
    nums[-1] = -Infinity
    nums[len] = -Infinity
    for(let i=0;i<len;i++){
        if(nums[i] > nums[i-1] && nums[i] > nums[i+1]){
            return i
        }
    }
};

//二分法
var findPeakElement = function(nums) {
    let low = 0
    let high = nums.length - 1
    while(low < high){
        let mid = Math.floor((low + high) / 2)
        if(nums[mid+1] > nums[mid]){
            low = mid + 1
        } else {
            high = mid
        }
    }
    return high
};
```

### 14 674最长的连续递增序列 [连续子序列]

```
给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度
输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findLengthOfLCIS = function(nums) {
    let len = nums.length
    if(len===0) return 0 //边界条件
    let maxLen = 1
    let start;
    for(let i=0;i<len;i++){
        start = nums[i]
        for(let j=i+1;j<len;j++){
            if(nums[j] > start){
                maxLen = maxLen > j-i+1?maxLen:j-i+1 //更新状态保持最大
                start = nums[j]
            } else {
                break
            }
        }
    }
    return maxLen
};
```

### 15 746使用最小的花费爬楼梯 [动态规划]

```
数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。
每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。
您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
```

```js
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    let len = cost.length
    if(len < 1) return 0
    let dp = []
    cost.push(0) //延长数组
    for(let i=0;i<cost.length;i++){
        if(i === 0){//边界
            dp[0] = cost[i]
        } else if(i === 1){//边界
            dp[i] = cost[i]
        } else {
            dp[i] = Math.min(dp[i-2],dp[i-1]) + cost[i]//递归式
        }
    }
    return dp[cost.length - 1]
};
```

### 16 56合并区间 [先排序]

```
给出一个区间的集合，请合并所有重叠的区间。
输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

```js
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    let len = intervals.length
    let res = []
    if(len === 0){return []} //边界
    if(len === 1){return [intervals[0]]}//边界
    intervals.sort((a,b)=>a[0]-b[0])//排序
    res.push(intervals[0])
    for(let i=1;i<len;i++){
        let per = res.pop()
        let cur = intervals[i]
        if(cur[0]>=per[0] && cur[0] <= per[1]){
            res.push([per[0],Math.max(per[1],cur[1])])
        } else {
            res.push(per,cur)
        }
    }
    return res

};
```

### 17 46全排列 [递归回溯]

```
给定一个 没有重复 数字的序列，返回其所有可能的全排列。
```

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    let res = []
    function backTrack(path,rest){
        if(rest.length === 0){
            res.push(path.slice(0))
            return
        }
        for(let i=0;i<rest.length;i++){
            if(rest[i+1] !== undefined && rest[i+1] === rest[i]){ //减枝 如果数字有重复的
                continue
            }
            const choose = rest.splice(i,1)[0]
            path.push(choose)
            backTrack(path,rest)
            rest.splice(i,0,choose)
            path.pop()
        }
    }
    backTrack([],nums)
    return res
};
```

### 18 15三数之和为0 [先排序]

```
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
注意：答案中不可以包含重复的三元组。
```

```js
var threeSum = function(nums) {
    let len = nums.length
    let ans = []
    if(len < 3) return []
    nums.sort((a,b) => a-b)
    for(let i=0;i<len;i++){
        if(nums[i] > 0) break; //第一个数比0大，就不可能成立
        if(i > 0 && nums[i] === nums[i-1]) continue;//去掉重复
        let L = i+1
        let R = len-1
        while(L < R){
            let sum = nums[i] + nums[L] + nums[R]
            if(sum === 0){
                ans.push([nums[i],nums[L],nums[R]])
                while(L < R && nums[L] === nums[L+1]){//去掉重复
                    L++
                }
                while(L < R && nums[R] === nums[R-1]){//去掉重复
                    R--
                }
                L++;
                R--
            } else if(sum < 0){
                L++
            } else {
                R--
            }
        }
    }
    return ans
};
```

### 19 移动零 283

 ```
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。
 ```

```js
var moveZeroes = function(nums) {
    let end = nums.length
    for(let i=0;i<end;){
        if(nums[i] !== 0){
            i++
        } else {
            let tmp = nums.splice(i,1)[0]
            nums.push(tmp)
            end = end - 1
        }
    }
};
```

### 20 缺失数字 268

```
给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。
```

```js
//使用集合 额外空间
var missingNumber = function(nums) {
    let set = new Set(nums)
    for(let i=0,n=nums.length;i<=n;i++){
        if(!set.has(i)){
            return i
        }
    }
    return -1
};

//数学法 前N项和
```

### 21 寻找重复数287 数组中重复的数据442 找到数组中消失的数字448

```
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
输入: [1,3,4,2,2]
输出: 2


给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。
找到所有出现两次的元素。
你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？
输入:
[4,3,2,7,8,2,3,1]
输出:
[2,3]



给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。
找到所有在 [1, n] 范围之间没有出现在数组中的数字。
输入:
[4,3,2,7,8,2,3,1]
输出:
[5,6]
```

```js
//使用额外空间
var findDuplicate = function(nums) {
    let set = new Set()
    for(let i=0,len=nums.length;i<len;i++){
        if(set.has(nums[i])){
            return nums[i]
        } else {
            set.add(nums[i])
        }
    }
};

//不使用额外空间 但是会更改数组
var findDuplicate = function(nums) {
    let len = nums.length
    for(let i=0;i<len;i++){
        let idx = Math.abs(nums[i]) - 1
        if(nums[idx] < 0){
            return Math.abs(nums[i])
        } else {
            nums[idx] = (-1) * nums[idx]
        }
    }
};


//数组中重复的数据
//使用额外空间
var findDuplicates = function(nums) {
    let ans = []
    let set = new Set()
    for(let v of nums){
        if(set.has(v)){
            ans.push(v)
        } else {
            set.add(v)
        }
    }
    return ans
};
//不使用额外空间 思想类似于计数排序
var findDuplicates = function(nums) {
    let ans = []
    let len = nums.length
    for(let i=0;i<len;i++){
        let idx = Math.abs(nums[i]) - 1
        if(nums[idx] < 0){
            ans.push(Math.abs(nums[i]))
        } else {
            nums[idx] = nums[idx] * (-1)
        }
        
    }
    return ans
};


//找到数组中消失的数字
var findDisappearedNumbers = function(nums) {
    let n = nums.length
    let ans = []
    for(let i=0;i<n;i++){
        let idx = Math.abs(nums[i]) - 1
        if(nums[idx] > 0){
            nums[idx] = -nums[idx]
        }
    }
    for(let j=0;j<n;j++){
        if(nums[j] > 0){
            ans.push(j+1)
        }
    }
    return ans
};
```

### 22 第三大的数字 414

```
给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。
输入: [2, 2, 3, 1]
输出: 1

解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。
存在两个值为2的数，它们都排第二。
```

```js
var thirdMax = function(nums) {
    let first = -Infinity,
        second = -Infinity,
        third = -Infinity;
    for(let num of nums){
        if(num === first || num === second || num === third){
            continue
        }
        if(num > first){
            third = second;
            second = first;
            first = num
        } else if(num > second){
            third = second;
            second = num
        } else if(num > third){
            third = num
        }
    }
    if(third === -Infinity){
        return first
    } else {
        return third
    }
};
```



## 1.2 路径问题

### 1 62不同路径 [动态规划 数学公式]

```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？
```

```js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    let res = [] //初始化动态规划矩阵
    for(let i=0;i<m;i++){
         res.push([])
        for(let j=0;j<n;j++){
            if(i===0 || j===0){
                res[i][j] = 1
            } else {
                res[i][j] = res[i-1][j] + res[i][j-1]//动态规划递推式（上方和左边）
            }
        }
    }
    return res[m-1][n-1]
};

//数学公式 C(m+n-2,m-1)
```

### 2 64最小路径和 [动态规划]

```
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。
```

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
    let dp = []
    for(let i=0;i<grid.length;i++){
        dp[i].push([])
        for(let j=0;j<grid[0].length;j++){
            if(i===0 || j===0){//边界条件1 在第一行或者第一列
                if(i === 0 && j===0){//在原点
                    dp[i][j] = grid[i][j]
                } else if(i===0){//在第一行
                    dp[i][j] = dp[i][j-1] + grid[i][j] 
                } else {//在第一列
                    dp[i][j] = dp[i-1][j] + grid[i][j]
                }
            } else {
                dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + grid[i][j]
            }
        }
    }
    return dp[i-1][j-1]
};
```

### 3 120三角形最小路径和 [动态规划]

```
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。
相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]

转变思路从最底层往最上面走
```

```js
/**
 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function(triangle) {
    let res = []
    //自低向上进行动态规划
    for(let i=triangle.length-1;i>=0;i--){
        res[i] = []
        for(let j=0;j<triangle[i].length;j++){
            if(i === triangle.length-1){ //在最底层
                res[i][j] = triangle[i][j]
            } else {
                res[i][j] = Math.min(res[i+1][j]+triangle[i][j],res[i+1][j+1]+triangle[i][j]) //动态规划递推式
            }
        }
    }
    return res[0][0]
};
```

## 1.3 字符串

* 子串是连续的
* 子序列不一定连续
* 维护状态，每次循环都要更新状态

### 1 3无重复字符的最长子串 [维护一个状态]

```
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    let len = s.length
    if(s===0) return 0 //边界条件
    let substr = ''
    let index;
    let maxLength = 0;
    for(let i=0;i<len;i++){
        index = substr.indexOf(s[i])
        if(index === -1){ //没有重复 直接加到子串中
            substr += s[i]
        } else { //有重复 在重复的位置进行切割
            substr = substr.slice(index+1) + s[i]
        }
        maxLength = Math.max(maxLength,substr.length)//更新状态
        
    }
    return maxLength
};
```





### 3 14最长的公共前缀 [往前累计]

```
编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 ""。
输入: ["flower","flow","flight"]
输出: "fl"
```

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    if(strs.length === 0) return ''//边界
    function commonPrefix(s1,s2){//找到两个字符串公共前缀的方法
        let len = Math.min(s1.length,s2.length)
        let maxCommonPrefix = ''
        for(let i=0;i<len;i++){
            if(s1[i] === s2[i]){
                maxCommonPrefix += s1[i]
            }else{
                break
            }
        }
        return maxCommonPrefix
    }
    let res = strs[0];
    for(let i=1;i<strs.length;i++){
        res = commonPrefix(res,strs[i])
        if(res === ''){
            break
        }
    }
    return res
};
```

### 4 20有效的括号 [栈]

```
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。
输入: "()[]{}"
输出: true
```

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    //首先去掉所有的空字符
    let str = s.replace(/\s{1,}/g,'')
    if(str.length === 1){return false}
    if(str === ''){return true}
    let stack = [str[0]] //初始化栈

    function code(str){//编码
        switch (str) {
            case '(':
                return 1
            case ')':
                return -1
            case '[':
                return 2
            case ']':
                return -2
            case '{':
                return 3
            case '}':
                return -3
        }
    }
    for(let i=1;i<str.length;i++){
        let lastEle = code(stack[stack.length - 1])
        if(lastEle + code(str[i]) === 0){//出栈
            stack.pop()
        } else {//入栈
            stack.push(str[i])
        }
    }
    return stack.length === 0
};
```

### 5 468验证IP地址 [正则]

```
验证IPv4 和IPv6是否合法
```

```js
/**
 * @param {string} IP
 * @return {string}
 */
var validIPAddress = function(IP) {
    // ipv4 的正则
    /^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-9])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-9])$/
    let IPv4 = '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
    let reIPv4 = '^(' + IPv4 + '\\.){3}' + IPv4 + '$'

    //ipv6正则
    /^([0-9a-fA-F]{1,4}\:){7}[0-9a-fA-F]{1,4}$/
    let IPv6 = '[0-9a-fA-F]{1,4}'
    let reIPv6 = '^(' + IPv6 + '\\:){7}' + IPv6 + '$'
    let re4 = new RegExp(reIPv4)
    let re6 = new RegExp(reIPv6)
    if(IP.includes('.') && re4.test(IP)){
        return 'IPv4'
    } else if(IP.includes(':') && re6.test(IP)){
        return 'IPv6'
    } else {
        return 'Neither'
    }

};
```



### 8 917仅仅翻转字母 [双指针]

```
给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。
输入："a-bC-dEf-ghIj"
输出："j-Ih-gfE-dCba"
```

```js
var reverseOnlyLetters = function(S) {
    let nonWordCode = {}
    let reg = /[A-Za-z]/
    let arr = S.split('')
    function swap(arr,i,j){
        [arr[i],arr[j]] = [arr[j],arr[i]]
    }
    for(let i=0,j=arr.length-1;i<j;){
        if(reg.test(arr[i])){
            if(reg.test(arr[j])){
                swap(arr,i,j)
                i++;
                j--
            } else {
                j--
            }
        } else {
            if(reg.test(arr[j])){
                i++
            } else {
                i++;
                j--
            }
        }
    }
    return arr.join('')
};
```

### 9 165比较版本号

```
比较两个版本号 version1 和 version2。
如果 version1 > version2 返回 1，如果 version1 < version2 返回 -1， 除此之外返回 0。

输入: version1 = "0.1", version2 = "1.1"
输出: -1  
输入：version1 = "1.01", version2 = "1.001"
输出：0
解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。
```

```js
var compareVersion = function(version1, version2) {
    let arr1 = version1.split('.').map(ele => parseInt(ele)) //将字符串变为数组，同时将每个元素去除前导0变为数字
    let arr2 = version2.split('.').map(ele => parseInt(ele))
    let len = Math.max(arr1.length,arr2.length)
    for(let i=0;i<len;i++){
        if(arr1[i] === undefined){
            arr1[i] = 0
        }
        if(arr2[i] === undefined){
            arr2[i] = 0
        }
        if(arr1[i] < arr2[i]){
            return -1
        } else if(arr1[i] > arr2[i]){
            return 1
        } else {
            continue
        }
    }
    return 0
};
```

### 10 71简化路径 [栈]

```
输入："/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。

输入："/a/./b/../../c/"
输出："/c"
```

```js
var simplifyPath = function(path) {
    let stack = []
    let arr = path.split('/')
    for(let v of arr){
        if(v === '.' ||  v === ''){
            continue
        } else if(v == '..'){
            stack.pop()
        } else {
            stack.push(v)
        }
    }
    return '/' + stack.join('/')
};
```

### 11 392判断一个字符串是否为另一个字符串的子序列 [双指针] ++

```
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
s = "abc", t = "ahbgdc"
返回 true.
```

```js
//O(m+n)
var isSubsequence = function(s, t) {
    let n = s.length
    let m = t.length
    let i=0
    let j=0
    while(i < n && j < m){
        if(s[i] === t[j]){
            i++
        }
        j++
    }
    return i === n
};
```



## 1.4 链表

* 尽量使用指针
* 新建一个链表使用哑结点，最后删除头部节点
* 对于头部节点的处理和其他节点的处理要分开讨论

### 1 2两数相加 [同时遍历两个链表]

* 所有数字相加，都先把原始的数字颠倒，这样就可以从第0个位置开始遍历，最后再把结果颠倒就可以得到正确的答案
* 本题的输入本来就是颠倒后的，结果也要求不用颠倒，故不需要事先颠倒

```
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    //初始化两个指针
    let p1 = l1
    let p2 = l2
    //存放结果的链表 一个哑结点
    let res = new ListNode('$')
    let pr = res
    let addin = 0
    let a1;
    let a2;
    while(p1 || p2){
        a1 = p1 ? p1.val : 0
        a2 = p2 ? p2.val : 0
        if(a1 + a2 + addin >= 10){
            pr.next = new ListNode(a1 + a2 + addin - 10)
            addin = 1
        } else {
            pr.next = new ListNode(a1 + a2 + addin)
            addin = 0
        }
        //移动指针
        p1 ? p1 = p1.next : ''
        p2 ? p2 = p2.next : ''
        pr = pr.next
    }
    //如果加完还有进位,再处理
    if(addin === 1){
        pr.next = new ListNode(1)
    }
    return res.next //返回的结果要去掉哑结点
};
```

### 2 翻转链表++ 206

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL

#步骤
  null  1 -> 2 -> 3 -> 4
1.pre  cur  temp
2.cur.next = pre
  null<-1   2 -> 3 -> 4
  pre  cur temp
3.pre = cur,cur = temp
  null<-1   2 -> 3 -> 4
       pre cur  temp
 最后
 null<-1<-2<-3<-4
               pre
```

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    //初始化
    let [pre,cur] = [null,head]
    while(cur){
        let temp = cur.next //1.将目前这个节点之后的部分进行存储
        cur.next = pre //2.关键
        //3.两个指针都前移动一位
        pre = cur
        cur = temp
    }
    return pre
};
```

### 3 92翻转两个位置之间的链表

```
反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
1 ≤ m ≤ n ≤ 链表长度。
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```

```js
/**
 * @param {ListNode} head
 * @param {number} m
 * @param {number} n
 * @return {ListNode}
 */
var reverseBetween = function(head, m, n) {
    if(m === n) return head //边界条件
    let res = new ListNode('$');
    res.next = head
    let pre = res;//指向m-1的位置,初始化为当前头结点的前一个节点，这也是为什么要创建一个哑结点
    let aft = head; //指向n+1的位置
    let cur = head; //指向m的位置
    let count = 1;
    let stack = [] //用一个栈来保存要翻转的节点的值
    //下面这个循环用来找出pre aft应该位于m-1 n+1的位置
    while(cur){
        if(count === m - 1){
            pre = cur
        }
        if(count >= m && count <= n){
            stack.push(cur.val)
        }
        if(count === n){
            aft = cur.next
        }
        cur = cur.next
        count++
    }
    //将栈中的值保存到pre中
    while(stack.length > 0){
        pre.next = new ListNode(stack.pop())
        pre = pre.next
    }
    pre.next = aft
    return res.next //返回值要去除头部节点
};
```

### 4 21合并两个有序链表 [同时遍历两个链表] ++

```
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

```js
var mergeTwoLists = function(l1, l2) {
    let res = new ListNode('$') //初始新建一个哑结点
    //初始化三个指针
    let p1 = l1
    let p2 = l2
    let pr = res
    let a1,a2
    while(p1 || p2){//同时循环，直到都到了链表的尾部null
        a1 = p1 ? p1.val : Infinity
        a2 = p2 ? p2.val : Infinity 
        if(a1 > a2){
            pr.next = new ListNode(a2)
            p2 ? p2 = p2.next : ''//移动指针,只有不为null才移动指针
        } else {
            pr.next = new ListNode(a1)
            p1 ? p1 = p1.next : ''//移动指针,只有不为null才移动指针
        }
        pr = pr.next
    }
    return res.next
};
```

### 5 检查链表是否有环 141 [遍历一次 快慢指针] ++

```
给定一个链表，判断链表中是否有环。
```

```js
var hasCycle = function(head) {
     //只有一个节点或者没有节点
    if(!head || !head.next){
        return false
    }
    let slow = head
    let fast = head
    while(fast && fast.next){
        slow = slow.next
        fast = fast.next.next
        if(slow === fast){
            return true
        }
    }
    return false
};

//修改原始链表
var hasCycle = function(head) {
    let pCur = head;
    while(pCur){
        if(pCur.flag === 'LOOP'){
            return true
        }
        pCur.flag = 'LOOP';
        pCur = pCur.next
    }
    return false
};
```

### 6 环形链表返回入环的第一个节点 142 [使用额外空间] ++

```
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
说明：不允许修改给定的链表。

```

```js
//使用额外空间
var detectCycle = function(head) {
   if(head === null){
       return null
   }
   let set = new Set()
   let pCur = head;
   while(pCur){
       if(set.has(pCur)){
           return pCur
       } else {
           set.add(pCur)
       }
       pCur = pCur.next
   }
    return null
};

//修改原始的链表
var detectCycle = function(head) {
    if(!head || !head.next) return null
    let flag = true
    let p = head
    while(p){
        if(p.flag){
            return p
        }
        p.flag = true
        p = p.next
    }
    return null
};

//快慢指针
var detectCycle = function(head) {
    if(!head || !head.next){
        return null
    }
    let slow = head
    let fast = head
    while(fast && fast.next){
        fast = fast.next.next
        slow = slow.next
        if(fast === slow){
            break
        }
    }
    if(fast !== slow){ //如果链表没有环
        return null
    }
    slow = head //慢指针回到起点
    while(slow !== fast){
        slow = slow.next
        fast = fast.next
    }
    return slow
};
```

### 7 删除排序链表中的重复元素 83 [遍历一次] ++

```
输入: 1->1->2->3->3
输出: 1->2->3
```

```js
var deleteDuplicates = function(head) {
    let p = head
    while(p && p.next){//不指向最后一个节点
        if(p.val === p.next.val){//如果该节点和后一个节点相同，就删除后一个节点
            p.next = p.next.next
        } else {
            p = p.next
        }
    }
    return head
};
```

### 8 86分割链表 [遍历将链表分割成两部分]

```

给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。
你应当保留两个分区中每个节点的初始相对位置。

输入: head = 1->4->3->2->5->2, x = 3
输出: 1->2->2->4->3->5
```

```js
//将链表
var partition = function(head, x) {
    let less = new ListNode('$')
    let great = new ListNode('$')
    let p = head
    let pl = less
    let pg = great
    while(p){
        if(p.val >= x){
            pg.next = new ListNode(p.val)
            pg = pg.next
        } else {
            pl.next = new ListNode(p.val)
            pl = pl.next
        }
        p = p.next
    }
    pl.next = great.next
    return less.next
};
```

### 9 找到相交链表的节点  160 [使用额外空间] ++

```
编写一个程序，找到两个单链表相交的起始节点
```

```js
//这个耗时 不用额外空间
var getIntersectionNode = function(headA, headB) {
    let pA = headA
    while(pA){
        let pB = headB
        while(pB){
            if(pA === pB){
                return pB
            }
            pB = pB.next
        }
        pA = pA.next
    }
    return null
};

//速度很快 使用额外空间
var getIntersectionNode = function(headA, headB) {
   let pa = headA
   let pb = headB
   let set = new Set()
   while(pa){
       set.add(pa)
       pa = pa.next
   }
   while(pb){
       if(set.has(pb)) return pb
       pb = pb.next
   }
   return null
};

//更简洁的方法
var getIntersectionNode = function(headA, headB) {
    let pA = headA
    let pB = headB
    while(pA !== pB){
        pA === null ? pA = headB : pA = pA.next
        pB === null ? pB = headA : pB = pB.next
    }
    return pA
};
```

### 10 328奇偶链表[遍历将链表分割成两部分]

```
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。
```

```js
var oddEvenList = function(head) {
    let even = new ListNode('$')
    let odd = new ListNode('$')
    let pe = even
    let po = odd
    let p = head
    let isOdd = true
    while(p){
        if(isOdd){
            po.next = new ListNode(p.val)
            po = po.next
            isOdd = false
        } else {
            pe.next = new ListNode(p.val)
            pe = pe.next
            isOdd = true
        }
        p = p.next
    }
    po.next = even.next
    return odd.next
};
```

### 11 61旋转链表

* 先将链表闭合，然后在位置size - k % size处断开

```js
var rotateRight = function(head, k) {
    if(head === null) return null
    let p = head
    let cur = head
    let size = 1
    let pos = 1
    while(p.next){
        size++
        p = p.next
    }
    p.next = head//形成环
    let newList = head.next//形成环过后才能指定
    while(pos !== (size - k % size)){
        pos++
        cur = cur.next
        newList = newList.next
    }
    cur.next = null//在指定位置处断开
    return newList 
};
```

### 12 K个一组翻转链表 25 [使用额外空间] ++

```
给你这个链表：1->2->3->4->5
当 k = 2 时，应当返回: 2->1->4->3->5
当 k = 3 时，应当返回: 3->2->1->4->5
```

```js
var reverseKGroup = function(head, k) {
    let res = new ListNode('$')
    let count = 0
    let stack = []
    let p = head
    let cur = res
    while(p){
        count++
        stack.push(p.val)
        if(count === k){
            while(stack.length > 0){
                cur.next = new ListNode(stack.pop())
                cur = cur.next
            }
            count = 0
        }
        p = p.next
    }
    while(stack.length > 0){
        cur.next = new ListNode(stack.shift())
        cur = cur.next
    }
    return res.next
};
```





## 1.5 树的层序遍历

```js
function TreeNode(val){
    this.val = key;
    this.left = null;
    this.right = null
}
```



树 > 二叉树 > 完全二叉树 > 满二叉树

* 二叉树 每个节点的度(子节点)最大为2
* 完全二叉树 (从上到下，从左到右，没有空的节点，就是满的·)
* 满二叉树（除了叶子节点，所有的节点都是满的并且所有的叶节点都在同一层）



* 二叉搜索树 (所有左节点比父节点小，右节点比父节点大)

* 中序遍历 非递归需要使用栈 (最左下角开始,最右下角结束 ↗↘) 左子树，根节点，右子树

  ```js
  //先最左下 再中 后右 ↗↘
  const inOrderTraverse = function(tree,callback){
      if(tree !== null){
          inOrderTraverse(tree.left,callback)
          callback(tree.key)
          inOrderTraverse(tree.right,callback)
      }
  }
  ```

* 先序遍历(从根节点开始,最右下角结束 ↙→) 根节点，左子树，右子树

  ```js
  //先根节点 -> 最左下 -> 右节点 
  const preOrderTraverse = function(tree,callback){
      if(tree !== null){
          callback(tree.key)
          preOrderTraverse(tree.left,callback)
          preOrderTraverse(tree.right,callback)
      }
  }
  ```

* 后序遍历(在根节点结束，最左下角开始 →↖) 左子树，右子树，根节点

  ```js
  const postOrderTraverse = function(tree,callback){
      if(tree !== null){
          postOrderTraverse(tree.left,callback)
          postOrderTraverse(tree.right,callback)
          callback(tree.key)
      }
  }
  ```

### 1 94二叉树的中序遍历 [非递归 使用栈 DFS]

```js
//递归 DFS
var inorderTraversal = function(root) {
    let res = []
    const dfs = function(node){
        if(node === null) return
        dfs(node.left)
        //在这里做点什么
        res.push(node.val)
        dfs(node.right)
    }
    dfs(root)
    return res
};
//非递归
var inorderTraversal = function(root) {
    if(root === null) return []
    let res = []
    let stack = []//用来存放节点
    while(stack.length !== 0 || root !== null){//如果栈不为空或者节点不为空
        if(root !== null){
            stack.push(root)
            root = root.left  
        } else {
            root = stack.pop()
            res.push(root.val)
            root = root.right
        }
    }
    return res
};
```

### 2 102二叉树的层序遍历 二叉树的右视图199

```
    3
   / \
  9  20
    /  \
   15   7
   
 [
  [3],
  [9,20],
  [15,7]
]

二叉树的右视图
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---

```



```js
//这个稍微在BFS的基础上做了一些改变，输出的形式不一样 正常BFS输出为[3,9,20,15,7]
var levelOrder = function(root) {
    if(root === null)return []
    let res = []
    let queue = []
    quene.push(root)//初始化队列
    while(quene.length > 0){
        let layer = []//用于存放这一层的数据
        let length = queue.length
        while(length > 0){//将该层的数据遍历完
            let now = quene.shift()
            layer.push(now.val)
            now.left ? queue.push(now.left) : ''
            now.right ? queue.push(now.right) : ''
            length --
        }
        res.push(layer)
    }
    return res
};

//二叉树的右视图
var rightSideView = function(root) {
    let ans = []
    if(root === null){
        return []
    }
    let queue = []
    queue.push(root)
    while(queue.length > 0){
        let len = queue.length
        let now;
        while(len > 0){
            now = queue.shift()
            now.left ? queue.push(now.left) : ''
            now.right ? queue.push(now.right) : ''
            len--
        }
        ans.push(now.val)
    }
    return ans
};
```

### 3 104二叉树的最大深度 [层次BFS]

```
    3
   / \
  9  20
    /  \
   15   7
   
输出3
```

```js
var maxDepth = function(root) {
    if(root === null) return 0
    let res = 0
    let queue = []
    queue.push(root)
    while(queue.length > 0){
        let len = queue.length
        while(len > 0){
            let now = queue.shift()
            now.left ? queue.push(now.left) : ''
            now.right ? queue.push(now.right) : ''
            len --
        }
        res++
    }
    return res
};
```

### 4 105从前序与中序遍历序列构造二叉树 [递归]

```
前序遍历 preorder = [3,9,20,15,7]  [根|左右]
中序遍历 inorder = [9,3,15,20,7]   [左|根|右]
注意:
你可以假设树中没有重复的元素。

    3
   / \
  9  20
    /  \
   15   7
```

```js
var buildTree = function(preorder, inorder) {
    if(inorder.length === 0){
        return null
    }
    let root = new TreeNode(preorder[0]) //从先序遍历找到根结点
    let midIndex = inorder.indexOf(preorder[0]) //在中序遍历中找到根结点的位置
    root.left = buildTree(preorder.slice(1,midIndex+1),inorder.slice(0,midIndex))//递归构造左子树
    root.right = buildTree(preorder.slice(midIndex+1),inorder.slice(midIndex+1))//递归构造右子树
    return root
};
```

### 5 106从中序与后序遍历序列构造二叉树 [构造]

```
中序遍历 inorder = [9,3,15,20,7] [左|根|右]
后序遍历 postorder = [9,15,7,20,3] [左右|根]
注意:
你可以假设树中没有重复的元素。

    3
   / \
  9  20
    /  \
   15   7
```

```js
var buildTree = function(inorder, postorder) {
    if(inorder.length === 0) {
        return null
    }
    let rootVal = postorder[postorder.length - 1] //从后序遍历找到根结点
    let root = new TreeNode(rootVal)
    let rootIdx = inorder.indexOf(rootVal) //在中序遍历中找到根结点的位置
    root.left = buildTree(inorder.slice(0,rootIdx),postorder.slice(0,rootIdx)) //递归构造左子树
    root.right = buildTree(inorder.slice(rootIdx+1),postorder.slice(rootIdx,-1)) //递归构造右子树
    return root
};
```

### 5 108将有序数组转换为二叉搜索树 [递归]

```
给定有序数组: [-10,-3,0,5,9]
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

```js
var sortedArrayToBST = function(nums) {
    if(nums.length === 0) return null
    let midIdx = Math.floor((nums.length - 1) / 2)
    let midEle = nums.splice(midIdx,1)[0]//取数组的中间元素 并把它删除
    let root = new TreeNode(midEle) //构造一个节点

    root.left = sortedArrayToBST(nums.slice(0,midIdx))//递归构造左子树
    root.right = sortedArrayToBST(nums.slice(midIdx))//递归构造右子树
    return root
};
```



### 8 112路径总和

```
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
```

```js
var hasPathSum = function(root, sum) {
    if(root === null)return false
    let res = false
    function calSum(arr){
        let totalSum = arr.reduce((pre,cur) => pre + cur,0)
        return totalSum
    }
    function dfs(stack,node,target){
        stack.push(node.val)
        if(node.left === null && node.right === null){
            if(calSum(stack) === target){
                res = true
            }
            return
        }
        if(node.left){
            dfs(stack,node.left,target)
            stack.pop()
        }
        if(node.right){
            dfs(stack,node.right,target)
            stack.pop()
        }
        
    }
    dfs([],root,sum)
    return res
};
```

## 1.6 树的递归

```js

//进入节点node，这里还可以带一些其他的状态也作为输入
function dfs(node){
//在节点node中做一些操作

//从该节点的状态判断是不是要终止
    if(不满足){
        return
    }
    
    //进入左节点
    dfs(node.left)
    一些操作//出左节点
    
    //进入右节点
    dfs(node.right)
    一些操作//出右节点
}
```

### 1 左叶子之和404

```
计算给定二叉树的所有左叶子之和
    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

```js
var sumOfLeftLeaves = function(root) {
    let ans = 0
    function dfs(root){
        if(root === null){
            return
        }
        if(root.left !== null && root.left.left === null && root.left.right === null){
            ans = ans + root.left.val
        }
        dfs(root.left)
        dfs(root.right)
    }
    dfs(root,ans)
    return ans
};
```

### 2 判断是否对称二叉树101 判断是否相同的树100 合并两个二叉树617

```
给定一个二叉树，检查它是否是镜像对称的。
```

```js
//迭代
var isSymmetric = function(root) {
   let queue = [root,root]
   while(queue.length > 0){
       let l = queue.shift()
       let r = queue.shift()
       if(l === null && r === null){
           continue
       }
       if(l === null || r === null){
           return false
       }
       if(l.val !== r.val){
           return false
       }
       queue.push(l.left)
       queue.push(r.right)
       queue.push(l.right)
       queue.push(r.left)
   }
   return true
};

//递归
var isSymmetric = function(root) {
   
   function dfs(root1,root2){
       if(root1 === null && root2 === null){
           return true
       }
       if(root1 === null || root2 === null){
           return false
       }
       if(root1.val !== root2.val){
           return false
       }
       return dfs(root1.left,root2.right) && dfs(root1.right,root2.left)
   }

   return dfs(root,root)
};

//判断相同的树
var isSameTree = function(p, q) {
    if(p === null && q === null){
        return true
    }
    if(p === null || q === null){
        return false
    }
    if(p.val !== q.val){
        return false
    }
    return isSameTree(p.right,q.right) && isSameTree(p.left,q.left)
};

//合并两个二叉树
var mergeTrees = function(t1, t2) {
    function merge(r1,r2){
        if(r1 === null){
            return r2
        }
        if(r2 === null){
            return r1
        }
        r1.val = r1.val + r2.val
        r1.left = merge(r1.left,r2.left)
        r1.right = merge(r1.right,r2.right)    
        return r1            
    }
    return merge(t1,t2) 
};
```

### 3 判断平衡二叉树 110

```
给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。
```

```js
var isBalanced = function(root) {
    //用于获取从该节点出发的最大高度
    function getHeight(node){
        if(node === null){
            return 0
        }
        return 1 + Math.max(getHeight(node.left),getHeight(node.right))
    }
    
    if(root === null){
        return true
    }
    if(Math.abs(getHeight(root.left) - getHeight(root.right)) > 1){
        return false
    }
    return isBalanced(root.left) && isBalanced(root.right)
};
```

### 4 利用排序数组构建高度最小的二叉搜索树 [面试题04.02]

```
给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。
```

```js
var sortedArrayToBST = function(nums) {
    if(nums.length === 0){
        return null
    }
    function dfs(nums,l,r){
        if(l > r){
            return null
        }
        let mid = Math.ceil((l+r) / 2)
        let tree = new TreeNode(nums[mid])
        tree.left = dfs(nums,l,mid-1)
        tree.right = dfs(nums,mid+1,r)
        return tree
    }
    return dfs(nums,0,nums.length-1)
};
```

### 5 判断一棵树是否是二叉搜索树 面试题04.05

```
实现一个函数，检查一棵二叉树是否为二叉搜索树
```

```js

//利用二叉搜索树的中序遍历是一个递增序列来写
var isValidBST = function(root) {
    let flag = -Infinity
    let res = true
    function dfs(root){
        if (root === null){
            return 
        }
        dfs(root.left)
        if(root.val > flag){
            flag = root.val
        } else {
            res = false
        }
        dfs(root.right)
    }
    dfs(root)
    return res
};
```



## 1.7 数学

### 1 交换一位数字使得数字最大

```
给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。
输入: 2736
输出: 7236
解释: 交换数字2和数字7。
```

```js
var maximumSwap = function(num) {
    function swap(arr,i,j){
        let temp = arr[i]
        arr[i] = arr[j]
        arr[j] = temp
    }
    let numArr = String(num).split('').map(ele => parseInt(ele))
    for(let i=0;i<numArr.length;i++){
        let max = numArr[i]
        let maxIdx = i
        for(let j=i+1;j<numArr.length;j++){
            if(max <= numArr[j]){ //这个等号很重要
                max = numArr[j]
                maxIdx = j
            }
        }
        if(maxIdx !== i && max !== numArr[i]){ //这里的同时条件判断很重要
            swap(numArr,i,maxIdx)
            break
        }
    }
    return parseInt(numArr.join(''))
};
```

### 2 求最大公因数

```js
//辗转相乘
function gcd(m,n){
  let min = Math.min(m,n)
  while(min !== 0){
    let rest = m % min
    m = min
    min = rest
  }
  return m
}

//递归写法
function gcd(m,n){
  if(m < n){
    [m,n] = [n,m]
  }
  if(n === 0){
    return m
  }
  return gcd(n,m % n)
}

//求n个数的最大公约数
function gcdN(arr){
  if(arr.length < 2){
    return
  }
  return arr.reduce((p,c) => gcd(p,c))
}
```

### 3 求最小公倍数 [需要依靠最大公因数]

```js
//两个数的最小公倍数
function lcm(m,n){
  return m*n / gcd(m,n)
}

//n个数的最小公倍数
function lcmN(arr){
  if(arr.length < 2){
    return
  }
  return arr.reduce((p,c) => lcm(p,c))
}
```

### 4 质因数分解

```js
function factorization(num){
  let k = 2
  let ans = []
  if(num <= k){
    return [num]
  }
  while(k <= num){
    if(num % k === 0){
      ans.push(k)
      num = num / k
    } else {
      k++
    }
  }
  return ans
}

console.log(factorization(999)) //[ 3, 3, 3, 37 ]
```

### 5 三数之和15

```
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
注意：答案中不可以包含重复的三元组。
给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

```js
var threeSum = function(nums) {
    let len = nums.length
    let ans = []
    if(len < 3) return []
    //1.排序
    nums.sort((a,b) => a-b)
    
    for(let i=0;i<len;i++){
        if(nums[i] > 0) break;
        if(i > 0 && nums[i] === nums[i-1]) continue;
        //指定左右两个指针
        let L = i+1
        let R = len-1
        //两个指针往中间走
        while(L < R){
            let sum = nums[i] + nums[L] + nums[R]
            if(sum === 0){
                ans.push([nums[i],nums[L],nums[R]])
                while(L < R && nums[L] === nums[L+1]){//左边去除重复
                    L++
                }
                while(L < R && nums[R] === nums[R-1]){//右边去除重复
                    R--
                }
                L++;
                R--
            } else if(sum < 0){//和小了 左指针移动一位
                L++
            } else {//和大了 右指针移动一位
                R--
            }
        }
    }
    return ans
};
```



## 1.8 连续子序列 子数组问题

* 连续子序列问题都可以使用暴力法解决（时间复杂度为O(n^2)）
* 降低到O(n)需要使用不同的技巧

### 1 最大子序和

```
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

```js
//暴力法 运行时间320ms
var maxSubArray = function(nums) {
    if(nums.length === 0){
        return 0
    }
    let ans = -Infinity;
    let sum = 0
    for(let i=0;i<nums.length;i++){
        sum = 0
        for(let j=i;j<nums.length;j++){
            sum = sum + nums[j]
            ans = ans > sum ? ans : sum
        }
    }
    return ans
};
//改进 使用一维动态规划，每一项代表到这个位置所能到达最大和
var maxSubArray = function(nums) {
    let dp = []
    let ans = -Infinity;
    for(let i=0;i<nums.length;i++){
        if(i===0){
            dp[i] = nums[0]
        } else {
            dp[i] = Math.max(dp[i-1] + nums[i],nums[i])
        }
        ans = ans > dp[i] ? ans : dp[i]
    }
    return ans
};
```

### 2 乘积最大子数组

```
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

```js
//暴力法
var maxProduct = function(nums) {
    let len = nums.length
    if(len === 0){
        return 0
    }
    let ans = -Infinity;
    let product = 1
    for(let i=0;i<len;i++){
        product = 1
        for(let j=i;j<len;j++){
            product = product * nums[j]
            ans = ans > product ? ans : product
        }
    }
    return ans
};

//改进 动态规划

```

### 3 连续的子数组和

```
给定一个包含 非负数 的数组和一个目标 整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。

输入：[23,2,4,6,7], k = 6
输出：True
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6。
```

```js
//暴力法
var checkSubarraySum = function(nums, k) {
    let len = nums.length
    if(len < 2){
        return false
    }
    let sum;
    for(let i=0;i<len;i++){
        sum = 0
        for(let j=i;j<len;j++){
            sum = sum + nums[j]
            if(sum === 0 && k === 0 && j > i){ // j > i是保证子数组的长度最少为2
                return true
            }
            if(sum % k === 0 && j > i){
                return true
            }
        }
    }
    return false
};

//改进 使用hashmap
```

### 4 和为K的子数组的个数560

```
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```

```js
//暴力法
var subarraySum = function(nums, k) {
    let len = nums.length
    if(len === 0){
        return 0
    }
    let sum = 0
    let ans = 0
    for(let i=0;i<len;i++){
        sum = 0
        for(let j=i;j<len;j++){
            sum = sum + nums[j]
            if(sum === k){
                ans++
            }
        }
    }
    return ans
};
//改进
```

### 5 最短的无序连续子数组581 [排序]

```
给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
你找到的子数组应是最短的，请输出它的长度。
输入: [2, 6, 4, 8, 10, 9, 15]
输出: 5
解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
```

```js
var findUnsortedSubarray = function(nums) {
    let len = nums.length
    if(len === 0){
        return 0
    }
    let snums = nums.slice(0)
    snums.sort((a,b) => a - b)
    let i=0
    let j=len-1
    while(i<=j){
        while(i<=len-1 && snums[i] === nums[i]){
            i++
        }
        while(j>=0 && snums[j] === nums[j]){
            j--
        }
        if(i<=j){
            return j - i + 1
        }
    }
    return 0
};
```

### 6 乘积小于K的子数组的数目713

```
给定一个正整数数组 nums。
找出该数组内乘积小于 k 的连续的子数组的个数。
输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。
```

```js
//暴力 超时
var numSubarrayProductLessThanK = function(nums, k) {
    let len = nums.length
    let product = 1;
    let ans = 0;
    for(let i=0;i<len;i++){
        product = 1
        for(let j=i;j<len;j++){
            product = product * nums[j]
            if(product >= k){
                break
            } else {
                ans ++
            }
        }
    }
    return ans
};

//改进
```

### 7 和至少为K的最短子数组862

```
返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。
如果没有和至少为 K 的非空子数组，返回 -1 。

输入：A = [2,-1,2], K = 3
输出：3
```

```js
//暴力 耗时7536ms
var shortestSubarray = function(A, K) {
    let len = A.length
    if(len === 0){
        return -1
    }
    let ans = Infinity;
    let sum = 0;
    for(let i=0;i<len;i++){
        sum = 0
        for(let j=i;j<len;j++){
            sum = sum + A[j]
            if(sum >= K){
                ans = ans > j - i + 1 ? j - i + 1 : ans
                break
            }
        }
    }
    return ans === Infinity ? -1 : ans
};

//改进 滑动窗口 由于里面含有负数 比较麻烦

```

### 8 和大于等于S的长度最小的子数组209

```
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。
输入：s = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

```js
//暴力
var minSubArrayLen = function(s, nums) {
    let len = nums.length
    if(len === 0){
        return 0
    }
    let sum = 0
    let ans = Infinity //初始化一个比nums中的元素还多数字就行了
    for(let i=0;i<len;i++){
        sum = 0
        for(let j=i;j<len;j++){
            sum = sum + nums[j]
            if(sum >= s){
                ans = ans > j-i+1 ? j-i+1:ans
                break
            }
        }
    }
    return ans === Infinity ? 0 : ans
};

//改进 滑动窗口
var minSubArrayLen = function(s, nums) {
    let len = nums.length
    if(len === 0){
        return 0
    }
    let sum = 0
    let ans = Infinity
    let left = 0
    for(let right=0;right<len;right++){
        sum = sum + nums[right]
        while(sum >= s){
            ans = ans > right - left + 1 ? right - left + 1 : ans
            sum = sum - nums[left]
            left++    
        }
    }
    return ans === Infinity ? 0 : ans
};
```

### 9 最长回文子串5 

```
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案
```

```js
var longestPalindrome = function(s) {
    let len = s.length
    if(len <= 1) return s
    let maxStr = '';
    let ans = ''
    for(let i=0;i<len;i++){
        let l = i-1;
        let r = i+1;
        maxStr = s[i]
        while(l >= 0 && s[l] === s[i]){//往左边走，直到找到第一个不相等的字符
            maxStr = s[l] + maxStr
            l--
        }
        while(r < len-1 && s[r] === s[i]){//往右边走，直到找到第一个不相等的字符
            maxStr = maxStr + s[r]
            r++
        }
        while(l >= 0 && r <= len-1 && s[l] === s[r]){//往两边走
            maxStr = s[l] + maxStr + s[r]
            l--
            r++
        }
        ans = ans.length > maxStr.length ? ans : maxStr
    }
    return ans
};
```



## 1.9 不连续子序列 子数组问题

### 1 300最长上升的子序列++

```
给定一个无序的整数数组，找到其中最长上升子序列的长度。
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

```js
//dp[i]表示以nums[i]结尾的递增子序列的最大长度
var lengthOfLIS = function(nums) {
    let len = nums.length
    if(len === 0){
        return 0
    }
    let dp = []
    let ans = 1
    for(let i=0;i<len;i++){
        dp[i] = 1
        for(let j=0;j<i;j++){
            if(nums[j] < nums[i]){
                dp[i] = Math.max(dp[i],dp[j]+1)
            }
        }
        ans = ans > dp[i] ? ans : dp[i]
    }
    return ans
};

//334递增的三元子序列(n元都可以)
var increasingTriplet = function(nums) {
    let len = nums.length
    if(len < 3){
        return false
    }
    let dp = []
    let ans = 1
    for(let i=0;i<len;i++){
        dp[i] = 1
        for(let j=0;j<i;j++){
            if(nums[j] < nums[i]){
                dp[i] = Math.max(dp[i],dp[j]+1)
            }
        }
        ans = ans > dp[i] ? ans : dp[i]
        if(ans >= 3){
            return true
        }
    }
    return false
};
```

### 2 354 俄罗斯套娃信封问题

```
给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。
请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。
```

```js
//和上一题一样
var maxEnvelopes = function(envelopes) {
    let len = envelopes.length
    if(len === 0){
        return 0
    }
    envelopes.sort((a,b) => a[0] - b[0])
    let dp = []
    let ans = 1
    for(let i=0;i<len;i++){
        dp[i] = 1
        for(let j=0;j<i;j++){
            if(envelopes[j][0] < envelopes[i][0] && envelopes[j][1] < envelopes[i][1]){
                dp[i] = Math.max(dp[i],dp[j]+1)
            }
        }
        ans = ans > dp[i] ? ans : dp[i]
    }
    return ans
};
```

### 3 128最长连续序列

```
给定一个未排序的整数数组，找出最长连续序列的长度。
要求算法的时间复杂度为 O(n)。
输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

```js
//使用集合 集合的查找事件复杂度为O(1)
var longestConsecutive = function(nums) {
    let ans = 1;
    let len = nums.length
    if(len === 0){
        return 0 
    }
    let numSets = new Set(nums)
    for(let v of numSets.values()){
        let now = v
        let tempLen = 1
        while(numSets.has(now-1)){
            tempLen++
            now = now - 1
        }
        ans = ans > tempLen ? ans : tempLen
    }
    return ans
};
```

### 4 1143最长公共子序列 [动态规划]

```
给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。

#该题对动态规划矩阵的边缘进行了扩展一圈，这样就不用处理复杂的边界条件了
```

```js
var longestCommonSubsequence = function(text1, text2) {
    let len1 = text1.length
    let len2 = text2.length
    let dp = []
    //下面这两步进行矩阵的边缘扩展(增加第-1行)
    dp[-1] = Array(len2).fill(0)
    dp[-1][-1] = 0//在该行增加第-1个位置的元素
    for(let i=0;i<len1;i++){
        //下面这两步进行矩阵的边缘扩展
        dp[i] = Array(len2).fill(0)
        dp[i][-1] = 0 //在该行增加第-1个位置的元素
        for(let j=0;j<len2;j++){
            //由于扩展了动态规划的矩阵,不需要进行复杂的边界条件处理
            if(text1[i] !== text2[j]){
                dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])
            } else {
                dp[i][j] = dp[i-1][j-1] + 1
            }
        }
    }
    return dp[len1-1][len2-1]
};
```

### 5 516最长回文子序列 [动态规划]

```
给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。
"bbbab"
4

##将s颠倒 问题转化为找两个字符串最长的公共子序列问题
```

```js
var longestPalindromeSubseq = function(s) {
    let s1 = s.split('').reverse().join('')
    let row = s1.length
    let col = s.length
    let dp = []
    dp[-1] = Array(col).fill(0)
    dp[-1][-1] = 0
    for(let i=0;i<row;i++){
        dp[i] = []
        dp[i][-1] = 0
        for(let j=0;j<col;j++){
            if(s1.charAt(i) === s.charAt(j)){
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])
            }
        }
    }
    return dp[row-1][col-1]
};
```



## 2.0 递归回溯 DFS

### 1 39无重复数字的组合总和

```
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以【无限制重复被选取】。
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
```

```js
var combinationSum = function(candidates, target) {
    function dfs(ans,path,sum,rest,target){
        if(sum >= target){
            if(sum === target){
                ans.push(path.slice(0))
            }
            return
        }
        for(let i=0;i<rest.length;i++){
            if(path[path.length - 1] && path[path.length-1] > rest[i]){ //这里保证ans中无重复
                continue
            }
            path.push(rest[i])
            sum = sum + rest[i]
            dfs(ans,path,sum,rest,target)
            sum = sum - rest[i]
            path.pop()
        }
    }
    let ans= []
    dfs(ans,[],0,candidates,target)
    return ans
};
```

### 2 46全排列

```
给定一个 没有重复 数字的序列，返回其所有可能的全排列。
```

```js
//无重复数据的全排列
var permute = function(nums) {
    let ans = []
    function dfs(path,nums){
        //在当前节点需要干什么
        if(nums.length === 0){
            ans.push(path.slice(0))
            return
        }
        //下一步进入哪一个节点(有些节点不需要进入)
        for(let i=0;i<nums.length;i++){
            const val = nums.splice(i,1)[0] //选择一个数，下轮该数字不能被选择
            path.push(nums[i])
            dfs(path,nums)//进入下一个节点
            //还原到当前节点的状态
            path.pop()
            nums.splice(i,0,val)
        }
    }
    dfs([],nums)
    return ans
};

//有重复数据的全排列
var permuteUnique = function(nums) {
    let ans = []
    function dfs(path,nums){
        //在当前节点需要干什么
        if(nums.length === 0){
            ans.push(path.slice(0))
            return
        }
        //下一步进入哪一个节点(有些节点不需要进入)
        for(let i=0;i<nums.length;i++){
            if(nums[i+1]!==undefined && nums[i+1] === nums[i]){//去除重复
                continue
            }
            const val = nums.splice(i,1)[0]
            path.push(val)
            dfs(path,nums)//进入下一个节点
            //还原到当前节点的状态
            nums.splice(i,0,val)
            path.pop()
        }
    }
    nums.sort((a,b) => a - b)
    dfs(ans,[],nums,undefined)
    return ans
};
```

### 3 77组合  39组合总和 40组合总和II

```
组合:
给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

组合总和:
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。
所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 


组合总和II:
给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次。
所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
```

```js
//组合
var combine = function(n, k) {
    let ans = []

    function getArray(n){
        let res = []
        for(let i=1;i<=n;i++){
            res.push(i)
        }
        return res
    }

    function dfs(path,nums,target){
        if(path.length === target){
            ans.push(path.slice(0))
        }
        for(let i=0;i<nums.length;i++){
            const last = path[path.length - 1]
            if(last !== undefined && nums[i] <= last){//不能选择比当前数字小的或者等于的数字
                continue
            } 
            path.push(val)
            dfs(path,nums,target)
            path.pop()
        }
    }

    let nums = getArray(n)
    dfs([],nums,k)
    return ans
};
//组合总和
var combinationSum = function(candidates, target) {
    function dfs(path,sum,nums,target){
        if(sum >= target){
            if(sum === target){
                ans.push(path.slice(0))
            }
            return
        }
        for(let i=0;i<nums.length;i++){
            const last = path[path.length - 1]
            if(last !== undefined && nums[i] < last){//不能选择比当前数字小的数
                continue
            }
            path.push(nums[i])
            sum = sum + nums[i]
            dfs(path,sum,nums,target)
            sum = sum - nums[i]
            path.pop()
        }
    }
    let ans= []
    dfs([],0,candidates,target)
    return ans
};



//组合总和II
var combinationSum2 = function(candidates, target) {

    let ans= []
    function dfs(sum,path,nums,target){
        if(sum >= target){
            if(sum === target){
                ans.push(path.slice(0))
            }
            return
        }

        for(let i=0;i<nums.length;i++){
            const last = path[path.length - 1]
            
            if(nums[i+1] !== undefined && nums[i+1] === nums[i]){//去除重复
                continue
            }
            if(last !== undefined && nums[i] < last){//不能选择比当前数字小的数
                continue
            }
            
            const val = nums.splice(i,1)[0]
            sum = sum + val
            path.push(val)
            dfs(sum,path,nums,target)
            sum = sum - val
            path.pop()
            nums.splice(i,0,val)
        }
    }
    
    
    candidates.sort((a,b) => a - b)
    dfs(0,[],candidates,target)
    return ans
};
```



### 4112树的路径总和

```
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
```

```js
var hasPathSum = function(root, sum) {
    if(root === null)return false
    let ans = false;

    function dfs(path,node,pathSum,sum){
        //在这个节点做什么
        if(node.left === null && node.right === null){
            if(pathSum === sum){
                ans = true
            }
            return
        }
        //下一步去哪一个节点
        if(node.left){
            //构造下一个节点的状态
            path.push(node.left.val)
            pathSum = pathSum + node.left.val
            dfs(path,node.left,pathSum,sum)//进入下一个节点
            //还原到当前节点的状态
            pathSum = pathSum - node.left.val 
            path.pop()
        }
        if(node.right){
            path.push(node.right.val)
            pathSum = pathSum + node.right.val
            dfs(path,node.right,pathSum,sum)
            pathSum = pathSum - node.right.val
            path.pop()
        }
    }
    dfs([root.val],root,root.val,sum)
    return ans
};
```

### 5 78子集

```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

```js
//无重复数字
var subsets = function(nums) {
    
    function dfs(nums,path,ans,eleNum){
        if(path.length === eleNum){
            ans.push(path.slice())
            return
        }
        for(let i=0;i<nums.length;i++){
            //不能选择比当前小的或者等于的，这里取等可以不用使用splice
            if(path[path.length-1] !== undefined && nums[i] <= path[path.length-1]){ 
                continue
            }
            path.push(nums[i])
            dfs(nums,path,ans,eleNum)
            path.pop()
        }
    }

    let len = nums.length
    let ans = []
    for(let i=0;i<=len;i++){
        dfs(nums,[],ans,i)
    }
    return ans
};

//有重复数字(不会)

```

### 6 93复原IP 

```
给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 '.' 分隔。

输入: "25525511135"
输出: ["255.255.11.135", "255.255.111.35"]
```

```js
var restoreIpAddresses = function(s) {
    let res = []
    //每个节点的状态,到目前的路径[],当前节点值,当前节点的索引开始位置
    function valid(node){
        if(node[0] === '0'){
            if(node.length === 1){
                return true
            } else {
                return false
            }
        } else {
            return parseInt(node) <= 255
        }   
    }

    function dfs(s,path,node,pos){
        //递归终止条件
        if(path.length === 4){
            if(pos===s.length){
                res.push(path.slice(0).join('.'))
                return
            }
            return
        }
        //选择下一个节点
        let node;
        for(let i=1;i<=3;i++){
            node = s.substr(pos,i)
            if(valid(node)){
                path.push(node) //做出选择
                pos = pos + i //更新指针位置
                dfs(s,path,node,pos)
                path.pop() //撤销选择
                pos = pos - i //还原指针位置
            } else {   
                break
            }
        }
    }
    dfs(s,[],s,0)
    return res
};
```

### 7 单词搜索 79

```
给定一个二维网格和一个单词，找出该单词是否存在于网格中。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
```

```js
var exist = function(board, word) {
    if(board.length === 0){
        return false
    }
    let row = board.length
    let col = board[0].length
    
    for(let i=0;i<row;i++){
        for(let j=0;j<col;j++){
            if(dfs(i,j,0)){
                return true
            }
        }
    }
    return false

    function dfs(i,j,pos){
        if(i >= row || i< 0 || j >= col || j < 0){
            return false
        }
        if(board[i][j] !== word[pos]){
            return false
        }
        if(pos === word.length - 1){
            return true
        }
        let tmp = board[i][j]
        board[i][j] = '-'
        let res = dfs(i-1,j,pos+1) || dfs(i+1,j,pos+1) || dfs(i,j-1,pos+1) || dfs(i,j+1,pos+1)
        board[i][j] = tmp
        return res
    }
};
```



## 2.1 BFS

### 1 岛屿数量

```
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
```

```js
var numIslands = function(grid) {
    let row = grid.length
    if(row === 0){
        return 0
    }
    let col = grid[0].length
    let ans = 0
    let quene = []
    //遍历二维网格 BFS
    for(let i=0;i<row;i++){
        for(let j=0;j<col;j++){
            if(grid[i][j] === '0'){
                continue
            }
            //BFS
            quene.push([i,j])
            ans++
            grid[i][j] = '0'//这步很重要，防止重复检查
            while(quene.length > 0){
                let [x,y] = quene.shift()
                //上
                if(x-1 >= 0  && grid[x-1][y] === '1'){
                    quene.push([x-1,y])
                    grid[x-1][y] = '0'
                }
                //右
                if(y+1 < col && grid[x][y+1] === '1'){
                    quene.push([x,y+1])
                    grid[x][y+1] = '0'
                }
                //下
                if(x+1 < row && grid[x+1][y] === '1'){
                    quene.push([x+1,y])
                    grid[x+1][y] = '0'
                }
                //左
                if(y-1 >= 0 && grid[x][y-1] === '1'){
                    quene.push([x,y-1])
                    grid[x][y-1] = '0'
                }
            }
        }
    }
    return ans
};
```

### 2 695岛屿的最大面积

```
给定一个包含了一些 0 和 1 的非空二维数组 grid 。
一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
```

```js
var maxAreaOfIsland = function(grid) {
        let row = grid.length
    if(row === 0){
        return 0
    }
    let col = grid[0].length
    let ans = 0
    let islandArea = 0
    let quene = []
    //遍历二维网格 BFS
    for(let i=0;i<row;i++){
        for(let j=0;j<col;j++){
            if(grid[i][j] === 0){
                continue
            }
            //BFS
            islandArea = 0
            quene.push([i,j])
            grid[i][j] = 0//这步很重要，防止重复检查
            while(quene.length > 0){
                let [x,y] = quene.shift()
                islandArea++
                //上
                if(x-1 >= 0  && grid[x-1][y] === 1){
                    quene.push([x-1,y])
                    grid[x-1][y] = 0
                }
                //右
                if(y+1 < col && grid[x][y+1] === 1){
                    quene.push([x,y+1])
                    grid[x][y+1] = 0
                }
                //下
                if(x+1 < row && grid[x+1][y] === 1){
                    quene.push([x+1,y])
                    grid[x+1][y] = 0
                }
                //左
                if(y-1 >= 0 && grid[x][y-1] === 1){
                    quene.push([x,y-1])
                    grid[x][y-1] = 0
                }
            }
            ans = ans > islandArea ? ans : islandArea
        }
    }
    return ans
};
```

### 3 130被围绕的区域××

```
给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。
找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
X X X X
X O O X
X X O X
X O X X

变为
X X X X
X X X X
X X X X
X O X X
```

```js
//找出所有连通的O即可

```

## 2.2 图

```
拓扑排序
1.根据依赖关系，构建邻接表、入度数组。
2.选取入度为 0 的数据，根据邻接表，减小依赖它的数据的入度。
3.找出入度变为 0 的数据，重复第 2 步。
4.直至所有数据的入度为 0，得到排序，如果还有数据的入度不为 0，说明图中存在环。
```

### 1 课程表 207

```
你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]
给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？

输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
```

```js
var canFinish = function(numCourses, prerequisites) {
    //1.构建邻接表 key为课程编号 value为数组表示上了编号为key的课程后可以选的课程列表
    let inDegreeArr = new Array(numCourses).fill(0)//所有课程的入度数组，索引为课程的编号
    let map = {}//邻接表
    for(let i=0;i<prerequisites.length;i++){
        inDegreeArr[prerequisites[i][0]]++
        if(map[prerequisites[i][1]]){
            map[prerequisites[i][1]].push(prerequisites[i][0])
        } else {
            map[prerequisites[i][1]] = [prerequisites[i][0]]
        }
    }

    //2.首先初始化一个队列 该队列初始化为入度为0的课程
    let queue = []
    for(let i=0;i<inDegreeArr.length;i++){
        if(inDegreeArr[i] === 0){
            queue.push(i)
        }
    }

    //3.使用BFS
    let count = 0
    while(queue.length > 0){
        let selected = queue.shift() //选择当前课程出队列
        count++
        let nextCourseArr = map[selected] //选择当前课程的后续课程
        if(nextCourseArr && nextCourseArr.length){
            nextCourseArr.forEach(course => {
                inDegreeArr[course] -- //将该课程的入度减1
                if(inDegreeArr[course] === 0){ //该课程的入度为0了 就可以加入大到队列中
                    queue.push(course)
                }
            })
        }
    }
    return count === numCourses
};
```

## 2.3 面试题

### 1 合并两个有序数组5  合并两个有序链表

```
给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
```

```js
var merge = function(nums1, m, nums2, n) {
    let idx1 = m-1
    let idx2 = n-1
    let tail = m+n-1
    while(idx2 >= 0){
        if(nums1[idx1] > nums2[idx2]){
            nums1[tail] = nums1[idx1]
            idx1--
        } else {
            nums1[tail] = nums2[idx2]
            idx2--
        }
        tail--
    }
    if(m === 0){ //如果第一个数组为空
        nums1.length = 0
        nums1.push(...nums2)
    } 
};
```

### 2 搜索旋转数组 

```
假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
你可以假设数组中不存在重复的元素。
你的算法时间复杂度必须是 O(log n) 级别。
```

```js
//数组中没有重复元素
var search = function(nums, target) {
    let len = nums.length
    if(len === 0) return -1
    if(len === 1) return nums[0] === target ? 0 : -1
    let l = 0
    let r = len - 1
    while(l <= r){
        let mid = Math.floor((l+r) / 2)
        if(nums[mid] === target){
            return mid
        }
        if(nums[l] <= nums[mid]){ // 搜索范围内前半部分是有序的
            if(nums[l] <= target && target < nums[mid]){ // 同时target在该有序的范围内
                r = mid - 1
            } else {
                l = mid + 1
            }
        } else { // 搜索范围内后半部分是有序的
            if(nums[mid] < target && target <= nums[r]){ // 同时target在该有序的范围内
                l = mid + 1
            } else {
                r = mid - 1
            }
        }
    }
    return -1
};

//有重复元素
var search = function(nums, target) {
    let len = nums.length
    if(len === 0) return false
    if(len === 1) return nums[0] === target 
    let l = 0
    let r = len - 1
    while(l <= r){
        let mid = Math.floor((l+r) / 2)
        if(nums[mid] === target){
            
            return true
        }
        if(nums[l] < nums[mid]){ // 搜索范围内前半部分是有序的
            if(nums[l] <= target && target < nums[mid]){ //同时target在该有序的范围内
                r = mid - 1
            } else {
                l = mid + 1
            }
        } else if(nums[l] > nums[mid]){//搜索范围内后半部分是有序的
            if(nums[mid] < target && target <= nums[r]){//同时target在该有序的范围内
                l = mid + 1
            } else {
                r = mid - 1
            }
        } else { //中间值等于左边界的值
            l++
        }
    }
    return false
};
```

### 3 寻找旋转排序数组中的最小值

```
假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
请找出其中最小的元素。
你可以假设数组中不存在重复元素。
```

```js
//数组中没有重复元素
var findMin = function(nums) {
    let len = nums.length
    let l = 0
    let r = len - 1
    while(l < r){
        let mid = Math.floor((l+r) / 2)
        if(nums[mid] > nums[r]){ //中间值和最右边的比
            l = mid + 1
        } else {
            r = mid //这里取mid就是为了防止最小值就是在mid位置上
        }
    }
    return nums[l]
};

//数组中有重复元素
var findMin = function(nums) {
    let len = nums.length
    let l = 0
    let r = len - 1
    while(l < r){
        let mid = Math.floor((l+r) / 2)
        if(nums[mid] > nums[r]){ //中间值和最右边的比
            l = mid + 1
        } else if(nums[mid] < nums[r]){
            r = mid
        } else {
            r = r - 1
        }
    }
    return nums[l]
};
```

### 4 一次编辑

```
字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。

输入: 
first = "pale"
second = "ple"
输出: True

输入: 
first = "pales"
second = "pal"
输出: False
```

```js
var oneEditAway = function(first, second) {
    let len1 = first.length
    let len2 = second.length
    let sub = len1 - len2
    if(Math.abs(len1 - len2) > 1){
        return false
    }
    let isFirstDifferent = false
    for(let i=0,j=0;i<len1&&j<len2;i++,j++){
        if(isFirstDifferent && first[i] !== second[j]){
            return false
        }
        if(first[i] !== second[j]){
            isFirstDifferent = true
            if(sub === 1){
                j--
            } else if(sub === -1){
                i--
            }
        }
    }
    return true
};
```

### 5 稀疏矩阵搜索 [二分]

```
稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。
 输入：words = ["at", "", "", "", "ball", "", "", "car", "", "","dad", "", ""], s = "ball"
 输出：4
```

```js
var findString = function(words, s) {
    let l = 0
    let r = words.length - 1
    while(l <= r){     
        while(words[l] === ''){
            l++
        }
        while(words[r] === ''){
            r--
        }
        let mid = Math.floor((l + r) / 2)
        while(words[mid] === ''){
            mid--
        }
        if(words[mid] < s){
            l = mid + 1
        } else if(words[mid] > s){
            r = mid - 1
        } else {
            return mid
        }
    }
    return -1
};
```



# #牛客题目

## 1.自己收集

1 将字符串转换为驼峰形式

```js
function cssStyle2DomStyle(sName) {
  let reg = /-(\w{1})/g
  if(sName[0] === '-'){ //如果以-开头，直接去掉
      sName = sName.slice(1)
  }
  return sName.replace(reg,function($,$1){
      return $1.toUpperCase()
  })
}
// font-size   fontSize
```

## 2.字节跳动

### 1 找零

```
Z国的货币系统包含面值1元、4元、16元、64元共计4种硬币，以及面值1024元的纸币。现在小Y使用1024元的纸币购买了一件价值为N(0<N≤1024)的商品，请问最少他会收到多少硬币？
```

```js
let n = parseInt(readline())
let res = 1024 - n
let ret = 0
function solve(res){
    if(res >= 64){
        ret = Math.floor(res / 64) + ret
        res = res % 64
        solve(res)
    } else
    if(res < 64 && res >= 16){
        ret = Math.floor(res / 16) + ret
        res = res % 16
        solve(res)
    } else
    if(res < 16 && res >= 4){
        ret = Math.floor(res / 4) + ret
        res = res % 4
        solve(res)
    } else
    if(res < 4 && res >= 1){
        ret = Math.floor(res / 1) + ret
        res = res % 1
        solve(res)
    } else
    if(res === 0){
        return
    }
}
solve(res)
console.log(ret)
```

### 2 水仙花数

```
春天是鲜花的季节，水仙花就是其中最迷人的代表，数学上有个水仙花数，他是这样定义的：“水仙花数”是指一个三位数，它的各位数字的立方和等于其本身，比如：153=1^3+5^3+3^3。 现在要求输出所有在m和n范围内的水仙花数。
输入数据有多组，每组占一行，包括两个整数m和n（100<=m<=n<=999）。
对于每个测试实例，要求输出所有在给定范围内的水仙花数，就是说，输出的水仙花数必须大于等于m,并且小于等于n，如果有多个，则要求从小到大排列在一行内输出，之间用一个空格隔开;如果给定的范围内不存在水仙花数，则输出no;每个测试实例的输出占一行。
对于每个测试实例，要求输出所有在给定范围内的水仙花数，就是说，输出的水仙花数必须大于等于m,并且小于等于n，如果有多个，则要求从小到大排列在一行内输出，之间用一个空格隔开;如果给定的范围内不存在水仙花数，则输出no;每个测试实例的输出占一行。
```

```js
let line;
let count;
function isVaild(num){
    let str = num + ''
    let res = 0
    for(let v of str){
        res = res + Math.pow(parseInt(v),3)
    }
    return res === num
}
while(line = readline()){
    count = []
    let m = parseInt(line.split(' ')[0])
    let n = parseInt(line.split(' ')[1])
    for(let i=m;i<=n;i++){
        if(isVaild(i)){
            count.push(i)
        }
    }
    if(count.length === 0){
        console.log('no')
    } else {
        let res = count.join(' ')
        console.log(res)
    }
}
```

