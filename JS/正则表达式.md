# 1 正则表达式入门

正则表达式的目的主要有两个：

* 查找特定的信息（==搜索==）
* 查找并编辑特定的信息（==替换==）

本质

* 正则表达式是一些用来匹配和处理文字的字符串（正则表达式是字符串）



# --从2到4的正则表达式模板只能匹配一个字符--

# 2 匹配单个字符

==对一个字符或者多个字符进行简单的匹配==

## 2.1 匹配纯文本

使用一个普通字符串作为正则表达式

```
文本
Hello,my name is Ben.please visit my website at http://www.forta.com/.

正则表达式
Ben

结果
字符串中的Ben会被匹配出来
```

## 2.2 匹配多个结果

（大部分）正则表达式引擎的默认行为是只返回第一个匹配结果，但是在不同的编程语言中可以实现多个匹配，比如JS中的g标志

## 2.3 字母大小写问题

默认正则表达式是区分字母大小写的，但是编程语言可以修改这一个设定，比如JS中的i标志。

```
正则表达式		 匹配结果
sales.			sales1	sales2  sales3  sales.
.a.				sal     pac     na1     sa2
.a..			sale    pac1    na1.    sa2.
.a.\.xls		na1.xls na2.xls sa1.xls
```



# 3 匹配一组字符

==使用元字符[]进行匹配（定义字符集合）==

```
正则表达式		 	 匹配结果
[ns]a.\.xls			na1.xls		na2.xls		sa1.xls		sac.xls
[ns]a[0-9]\.xls		na1.xls		na2.xls		sa1.xls
```

## 3.1 取非匹配

```
正则表达式		 	 匹配结果
[ns]a[^0-9]\.xls	nam.xls	
```

**注意：**^ 元字符将作用于给定字符集合里面的==所有字符或字符区间==，而不是仅限于紧跟在^字符后面的那一个字符或字符区间



# 4 使用元字符

* 元字符是一些在正则表达式有着特殊含义的字符
* 不能使用元字符本身来匹配该字符（如果要进行匹配，使用转义符进行转义）

## 4.1 对特殊字符进行转义

```
正则表达式		 	 匹配结果
myArray\[[0-9]\]	maArray[0]	maArray[1]
```

## 4.2 匹配空白字符

```
正则表达式		 	 匹配结果
[\b]				键盘Backspace键
\f					换页符（该符号独占一行）
\n					换行符（该符号独占一行）
\r					回车符（enter键）
\t					制表符（tab键）
\v					垂直制表符

\s					匹配任何一个空白字符（等价于[\f\n\r\t\v]）该模式似乎可以匹配空格
\S					匹配任何一个非空白字符（等价于[^\f\n\r\t\v]）
```

## 4.3 匹配特定的字符类别

### 4.3.1 匹配数字

```
正则表达式		 	 匹配结果
\d					任何一个数字字符（等价于[0-9]）
\D					任何一个非数字字符（等价于[^0-9]）
```

### 4.3.2 匹配字母和数字

```
正则表达式		 	 匹配结果
\w					任何一个字母数字字符（等价于[a-zA-Z0-9_]）
\W					任何一个非字母数字字符（等价于[^a-zA-Z0-9_]）
```

### 4.3.2 匹配中文

```
[\u4e00-\u9fa5]
```



# --从5到5正则表达式模板可以匹配多个字符

# 5 重复匹配

要使用重复匹配，必须使用量词

## 5.1 匹配一个或多个字符+

```
量词		 	 	   说明
+					匹配一个或者多个字符（等价于{1,}）

[0-9]+              可以匹配一个或者多个数字
[0-9+]				可以匹配一个数字或者一个+
```

在给字符集合加上+后缀的时候，必须把+放在这个字符集合的外面（如上面后两种情况）

## 5.2 匹配零个或多个字符*

*说明这个符号前面的字符是可选的

```
量词		 	 	   说明
*					匹配零个或者多个字符（等价于{0,}）

正则表达式		 	 	 匹配结果
\w+[\w.]*@[\w.]+\.\w+	ben@forta.com
```

## 5.3 匹配零个或一个字符？

```
量词		 	 	   说明
?					匹配零个或者一个字符（等价于{0,1}）

正则表达式		 	 匹配结果
https?://[\w./]+	http://www.forta.com/ https://www.forta.com/
```

## 5.4 设定重复匹配的次数

利用元字符{}

```
正则表达式		 	 				匹配结果
\d{1,2}[-\/]\d{1,2}[=\/]\d{2,4}	   4/8/03	10-6-2004	01-01-01
\d+:\$\d{3,}\.\d{2}				   1001:$496.80		1006:$414.90
```

## 5.5 防止过度匹配[重要]

正则表达式默认是会进行贪婪匹配的，它们在进行匹配时的行为模式是多多益善而不是适可为止，会尽可能地从一段文本的开头一直匹配到这段文本的末尾，而不是从这段文本的开头匹配到碰到的第一个匹配为止。

```
贪婪型元字符		 	 	   懒惰型元字符
*					       *？
+						   +？
{n,}					   {n,}?

正则表达式		 	 匹配结果
<[Bb]>.*</[Bb]>		<B>AK</B> and <B>HI</B>
<[Bb]>.*?</[Bb]>	<B>AK</B>
```



# 6 位置匹配++

针对某段文本中的特定位置进行匹配。

用来解决在是什么地方进行字符串匹配操作的问题

## 6.1 边界

* ==位置不是字符==
* ==位置是位于字符之间的东西==

### 6.1.1 单词边界

```
正则表达式		匹配结果
\b			   单词边界（想找这样一个位置，该位置位于\W和\w之间，常见的是空格和单词之间的位置）
\B			   非单词边界（除了\b的情况 想找这样一个位置，该位置位于 \W和\W 或者 \w和\w 之间，）

cat					cat scat scatt
\bcat				cat cats catt
\bcat\b				cat
cat\b				scat

输入			  		正则表达式		 	匹配结果
nine-digit			 \B-\B				无（因为这里的连字符前后的位置不是位于\W和\W之间的位置）
color - coded		 \B-\B				-(因为这里的连字符前后的位置位于\W(空格)和\W(-)之间的位置)
```

* \b 用来匹配这样一个位置，该位置位于一个能够用来构成单词的字符（\w）和一个不能用来构成单词的字符之间。常见的就是空格

### 6.1.2 字符串边界

与单词边界的区别：

* 字符串可以由很多单词组成

```
正则表达式		匹配结果
^			   字符串开头
$			   字符串结尾
```

* ^是有着多种用途的元字符之一，只有当它出现在一个字符集合里并且紧跟在左方括号[的后面时，才能发挥求非的作用

```
正则表达式					匹配结果
^\s*<\?xml.*\?>			   xml文档的开头,如：<?xml version="1.0" encoding="UTF-8" ?>
</[Hh][Tt][Mm][Ll]>\s*$	   HTML文档的结束标签，如：</html>
```

## 6.2 分行匹配模式

* 可以将换行符当成字符串的开始和结束

```
正则表达式					匹配结果
(?m)^\s*//.*$			   js中的行注释，如：//this is a function
```

* 许多正则表达式实现不支持这个符号



# 7 使用子表达式

* 使用符号（）
* 该符号可以把多个表达式==当成一个整体==

* 可以类比数学中的括号，作用差不多

## 7.1 子表达式

```
正则表达式					匹配结果
19|20\d{2}			   	   19 2001 2019
(19|20)\d{2}			   1967 1956 2001 2009
```

## 7.2 子表达式嵌套

* ==子表达式多重嵌套可以构造出功能极其强大的正则表达式==
* 但是会让模式变得难以阅读和理解

```
正则表达式					     
(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))

匹配结果
合法的IP地址
```

* 把嵌套子表达式弄明白的关键是要把它们拆开，每次只分析和理解一个子表达式式。由内后外的原则



# 8 回溯引用：前后一致匹配++

* 建立在子表达式上

* 回溯引用指的是模式的后半部分引用在前半部分中定义的子表达式

* 使用\0,\1,\2,....来表示，其中\0代表整个正则表达式匹配的内容，\1代表第一个子表达式匹配的内容

## 8.1 简单使用

```
正则表达式					匹配结果
<[Hh]([1-6])>.*?</[Hh]\1>  HTML中的h1-h6标签的内容，而不会出现匹配到这种情况<h1>xxx</h2>
```

## 8.2 回溯引用在替换中的应用

* ==简单的文本替换操作无须使用正则表达式==

```
输入					正则							  替换				替换结果
313-555-1234		 (\d{3})(-)(\d{3})(-)(\d{4})	($1) $3-$5		    (313) 555-1234
```

```
正则表达式					说明
\E						   结束\L或者\U转换
\l(小写L)					  把下一个字符或者子表达式转换为小写
\L						   把\L到\E之间的字符全部转换为小写
\u						   把下一个字符或者子表达式转换为大写
\U						   把\U到\E之间的字符全部转换为大写

正则表达式					 替换						匹配结果
(<[Hh]1>)(.*?)(</[Hh]1>)	$1\U$2\E\3				把h1标签中的内容全部转为大写  
```

* ==在对文本进行处理排版的时候，把文本分解为多个子表达式的做法非常有用，这样可以对文本进行更精确的控制==



# 9 前后查找++

* JS的正则表达式支持向前查找，不支持向后查找

## 9.1 向前查找

* 向前查找指定了一个必须匹配但==不在结果中返回的模式==
* 一个向前查找模式其实就是一个以?=开头的子表达式（被写在?=后面的文本不会在匹配结果中返回）

```
正则表达式					匹配结果					 翻译
.+(?=:)				       http   https   ftp		  这个字符串后面接着: 但是不要在结果中显示
.+(:)					   http:  https:  ftp:
```

* 负向向前查找(用得比较少)

```
语法					匹配结果
(?!=)
```

* ==总之，向前查找一般放在子表达式中==



## 9.2 向后查找[js实现了]

```
正则表达式					匹配结果
\$[0-9.]+				   $23.45   $899.00
(?<=\$)[0-9.]+				23.45   899.00
```

* 负向向后查找

```
语法					匹配结果
(?<!)
```

## 9.3 组合例子

```javascript
//1 取出时间中的年、月、日
var str = '2001-9-23';
str.match(/^\d+(?=-)/g)；//['2001']
str.match(/(?<=-)\d{1,2}(?=-)/g);//['9']
str.match(/(?<=-)\d+$/g);['23']
```



# 10 嵌入条件

* 用得比较少（而且好像很复杂）



# 11 使用方法

## 11.1 字符串方法

### 11.1.1 search

*  用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串
*  如果没有找到任何匹配的子串，则返回 -1;找到就返回第一个索引

```javascript
var str="Visit Runoob!"; 
var n=str.search("Runoob");

//结果
n = 6
```

### 11.1.2 match

* 返回一个数组或者字符串
* 如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null 
* 如果 regexp 有标志 g，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息 

```javascript
var str="The rain in SPAIN stays mainly in the plain"; 
var n=str.match(/ain/g);

//结果
ain,ain,ain
```

### 11.1.3 replace

* 替换字符串

### 11.1.4 split

* 分割字符串为数组



## 11.2 正则对象方法

### 11.2.1 exec

*  用于检索字符串中的正则表达式的匹配 
*  如果字符串中有匹配的值返回该匹配值，否则返回 null 

```javascript
var str="Hello world!";
//查找"Hello"
var patt=/Hello/g;
var result=patt.exec(str);
document.write("返回值: " +  result); 

//查找 "RUNOOB"
patt=/RUNOOB/g;
result=patt.exec(str);
document.write("<br>返回值: " +  result);

//结果
Returned value: Hello
Returned value: null
```

### 11.2.2 test

*  用于检测一个字符串是否匹配某个模式 
*  如果字符串中有匹配的值返回 true ，否则返回 false 

```javascript
var str="Hello world!";
//查找"Hello"
var patt=/Hello/g;
var result=patt.test(str);
document.write("返回值: " +  result); 

//查找 "Runoob"
patt=/Runoob/g;
result=patt.test(str);
document.write("<br>返回值: " +  result);

//结果
返回值: true
返回值: false
```