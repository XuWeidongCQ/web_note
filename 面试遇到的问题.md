#  #补充

## #.1 自己想到的

### 1  手写ajax

```js
function ajax(url,method,data){
    const xhr = new XMLHttpRequest()
    xhr.onreadystatechange = function(){
        if(xhr.readystate === 4){
            if(xhr.status === 200){
                console.log(xhr.responseText)
            } else {
                console.log(xhr.statusText)
            }
        }
    }
    xhr.open(method,url,true)
    xhr.send(data || {})
}

//使用promise
function http(url,method='GET',data=null){
  return new Promise((res,rej) => {
    let xhr = new XMLHttpRequest()
    xhr.open(method,url)
    xhr.send(data)
    xhr.onreadystatechange = function(){
      if(xhr.readyState === 4 && xhr.status === 200){
        res(xhr.responseText)
      } else {
        rej()
      }
    }
  })
}
```

### 2 sessionStorage如果同一个浏览器开两个窗口，数据可以用吗

不能，sessionStorage只能用于当前页面。localStorage可以实现同一个浏览器不同窗口的数据共享（这些窗口必须属于是相同的域名和端口）。

### 3 有哪些性能优化的方法 （三大部分）

```
第一部分:减小HTTP的请求次数(网络部分)
1.针对图片，图片大小控制合适,很多小图片可采用精灵图的方式
2.多图要进行图片的懒加载
3.数据请求做好缓存，下次请求直接使用缓存
4.尽可能地让资源能够在缓存中待得更久


第二部分:减小DOM操作次数,资源压缩
1.改变样式尽量避免直接操作style
2.部署上线js,css代码进行压缩
3.减少浏览器重绘与回流(如果必须使用，尽量使用不影响文档流的方式回流)


第三部分:用户体验
1.事件做好防抖与节流
2.避免首页白屏(常出现在前端渲染的情况下)
  a.前端渲染由于内容都是JS生成的，如果网络不好或者文件过大(css文件和js文件没有加载过来，会导致无法生成页面)
  b.所以必须减小文件的加载体积,压缩，分成一个一个小文件
  c.使用服务端渲染(在后台将页面渲染好了之后，再发送给浏览器)
  d.使用一个静态的骨架屏作为填充(使用webpack插件page-skeleton-webpack-plugin)
  e.使用预渲染,在webpack打包的时候就生成相关页面，而不需要使用后面的js生成(使用webpack插件prerender-spa-plugin)


1. 减少http请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器++
2. 前端模板 JS + 数据，减少由于HTML标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数++
3. 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能++
4. 当需要设置的样式很多时设置 className 而不是直接操作 style++
5. 少用全局变量、缓存DOM节点查找的结果。减少 IO 读取操作
6. 避免使用 CSS Expression（css表达式)又称 Dynamic properties(动态属性)
7. 图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳++
```

### 4 js延迟加载的方式有哪些 [4种]

js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。

* 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行,<body>标签之后
* 给 js 脚本添加 defer属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。
* 给 js 脚本添加 async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。
* 动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。比如在触发DOMContentLoaded事件后进行

### 5 深浅拷贝

* **浅拷贝：** 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

  ```
  Object.assign() 方法： 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
  
  ```
  

  
* **深拷贝：** 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。

  ```js
  乞丐版： 
  JSON.parse(JSON.stringify(object))，缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）
  Array.prototype.slice()：(只能深拷贝第一层的值，第二层的值是浅拷贝)
  扩展运算符(只能深拷贝第一层的值，第二层的值是浅拷贝)
  
  const deepClone = function(src){
    let res;
    if(Array.isArray(src)){
      res = []
      for(let v of src){
        res.push(deepClone(v))
      }
      return res
    } else if(typeof src === 'object'){
      res = {}
      for(const key in src){
        res[key] = deepClone(src[key])
      }
      return res
    } else {
      return src
    }
  }
  
  //vue-router源码的深度克隆
  function clone (value) {
    if (Array.isArray(value)) {
      return value.map(clone)
    } else if (value && typeof value === 'object') {
      const res = {}
      for (const key in value) {
        res[key] = clone(value[key])
      }
      return res
    } else {
      return value
    }
  }
  ```

### 6 图片预加载与图片懒加载

```
图片预加载：
图片预加载就是在网页全部加载之前，提前加载图片。当用户需要查看时可直接从本地缓存中渲染，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，用户可能会因为体验差而关闭浏览器

适用情形:
在首次屏幕展示上包含大量的图片

缺点
会牺牲服务器的性能
```

* 通过js提前图片缓存在内存中，即使该图片还没有在页面上显示
* 在页面上，每一个img标签都对应一个Image对象

```js
//一个数组用来存放图片的路径
let imgarr=new Array() 
imgarr[0]="http://www.baidu.com/img/baidu_logo.gif"; 
imgarr[1]="http://img.baidu.com/img/logo-img.gif"; 
imgarr[2]="http://img.baidu.com/img/logo-zhidao.gif"; 


function loadImage(imgUrlArr) { //传入一个图片的src组成的数组
     for(let i=0;i<imgUrlArr.length;i++){
         let img = new Image()
         img.src = imgUrlArr[i]
     }   
};
loadImage(imagarr) //调用这个方法，图片就会存在内存中，如果页面要使用这个图片，就会直接去内存中获取
```

```
图片懒加载：
有时候有的网页图片很多，但是屏幕一开始又不能全部显示（比如淘宝，京东这类的购物网站）,如果放任不管，浏览器会把HTML文档中的所有的图片全部请求过来，对服务器造成很大的压力。如果有很多人同时访问，服务器可能会崩溃，用户体验不好。

适用情形:
网站图片很多，但是一开始不能全部显示
```

```jsx
//假设所有要加载的图片如下
<div class='img-wrapper'>
    <img src='img/lodaing.gif' data-src='http://xxx/img1.jpg'></img>
    <img src='img/lodaing.gif' data-src='http://xxx/img2.jpg'></img>
    <img src='img/lodaing.gif' data-src='http://xxx/img3.jpg'></img>
    <img src='img/lodaing.gif' data-src='http://xxx/img4.jpg'></img>
    <img src='img/lodaing.gif' data-src='http://xxx/img5.jpg'></img>
    <img src='img/lodaing.gif' data-src='http://xxx/img6.jpg'></img>
    <img src='img/lodaing.gif' data-src='http://xxx/img7.jpg'></img>
</div>

1.给所有的图片的src初始设为loading图片，同时设置自定义的属性data-src为真正的src
2.判断哪些图片即将进入可视区，那么这个图片就要被加载(已经加载过的不用加载)


window.onload = function(){
    let imgs = document.images //拿到所有的图片
    let canRun = true //节流要使用的闭包数据
    function lazyload(imgs){
        let innerHeight = window.innerHeight //拿到浏览器可视区的高度
        for(let i=0;i<imgs.length;i++){
           const imgUrl = imgs[i]['dataset']['src']
           //如果图片已经存在就不要在设置属性了
            if(imgs[i].src !== imgUrl && imgs[i].getBoundingClientRect()['top'] < innerHeight){
              imgs[i].setAttribute('src',imgUrl)
            }
        }
    }
    
    lazyLoad(imgs) //执行一次，防止首页上的图片不出来
    window.onscroll = function(){ //滚动的时候进行监听，滚动会一直频繁的触发，这里可以使用节流
        if(canRun){
            lazyLoad(imgs)
            canRun = false
            setTimeOut(() => canRun = true,1000)
        }
    }
}

//可以不使用计算img标签的位置信息，使用原生提供的IntersectionObserver
var io = new IntersectionObserver(callback, option);
// 开始观察某一个元素
io.observe(document.getElementById('example'));
// 停止观察
io.unobserve(element);
// 关闭观察器
io.disconnect();
```



### 7 使用promise实现图片按顺序加载

```js
let getImage = function(src){
    let p = new Promise(res => {
        let img = document.createElement('img')
        img.onload = function(){
            res()
        }
        img.src= src
    })
    return p
}

getImage(src1).then(() => return getImage(src2)).then(() => getImage(src3))
```

### 8 var let和const (5点)

|                      | var          | let          | const                        |
| -------------------- | ------------ | ------------ | ---------------------------- |
| 声明                 | 可以重复声明 | 不能重复声明 | 不能重复声明（不能占用null） |
| 作用域               | 函数作用域   | 块级作用域   | 块级作用域                   |
| 提升                 | 可以         | 不可以       | 不可以                       |
| 修改                 | 可以         | 可以         | 不能（引用变量可以）         |
| 是否挂载到window对象 | 全局声明挂载 | 不会         | 不会                         |

### 9 localStorage 、cookie、sessionStorage的区别(3点)

```
相同点:
都保存在浏览器端，同源才能使用
```

|          | localStorage       | sessionStorage       | cookie                                 |
| -------- | ------------------ | -------------------- | -------------------------------------- |
| 生命周期 | 永久，除非手动删除 | 浏览器窗口关闭就消失 | 可以设置有效期,字段expire              |
| 数据字段 | key value          | key value            | name value domain path expire httpOnly |
| 数据大小 | 一般5MB            | 一般5MB              | 4k                                     |
| HTTP通信 | 不自动参与         | 不自动参与           | 自动发送                               |
| 易用性   | 读取有专门的接口   | 读取有专门的接口     | 读取需要自己封装                       |

### 10 tcp、udp的区别(4点)，使用场景

```
TCP的优点： 
可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。

TCP的缺点： 
慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

适用于：(需要准确无误的传输的)
HTTP
文件FTP
邮件POP
远程登录SSH
```

```
UDP的优点： 
快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… 

UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。

适用于:(对速度要求)
即时通信(语音通话)
在线视频(视频通话)
```

| TCP                                  | UDP                                      |
| ------------------------------------ | ---------------------------------------- |
| 有连接（发送数据前需要提前建立连接） | 不需要提前建立连接                       |
| 对系统的资源要求较多                 | 对系统资源要求少                         |
| 传输慢                               | 传输快                                   |
| 传输可靠                             | 传输不可靠（数据容易丢失，容易重复发送） |

### 11.怎么保证登录安全

### 12.webpack主要几个配置项(前5点)

| 配置项        | 作用                                                         | 特点                      |
| ------------- | ------------------------------------------------------------ | ------------------------- |
| entry         | 指定打包的开始文件                                           |                           |
| output        | 打包后的bundle输出到哪里                                     |                           |
| loader/module | 帮助webpack处理一些非js的文件，webpack默认只能处理js文件和json文件 | 是一个nodejs模块          |
| plugins       | 可以执行比Loader更广的任务，比如打包优化和压缩，定义环境变量 | 一个构造函数(使用new调用) |
| mode          | 指示webpack使用相应模式的配置                                |                           |
| devServe      | 开发服务器的配置                                             |                           |
| devtool       | 配置打包后的代码到源代码的映射方式                           |                           |

* devtool取值

| 部分值                               | 作用                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| inline(内联) hidden(外联) eval(内联) | 决定生成的sourcemap文件单独的还是嵌入到打包的js文件中（不写这部分就是外联） |
| nosource                             | 决定浏览器是否能够把错误定位到源代码的位置 (不写这部分是可以定位) |
| cheap cheap-module                   | 决定浏览器定位错误代码的粒度                                 |
| source-map(这一项必写)               |                                                              |

```js
//例子
const {resolve} = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
    entry:'./src/main.js',
    output:{
        filename:'bundle.[contenthash:10].js',
        path:resolve(__dirname,'build')
    },
    module:[
        {test:/\.less$/,use:['style-loader','css-loader','less-loader']}
    ],
    plugins:[new HtmlWebpackPlugin({template:'./src/index.html'})],
    mode:'development',
    devServe:{
        contentBase:resolve(__dirname,'build'),
        compress:true,
        port:3000,
        open:true,
        hot:true
    },
    devtool:'inline-source-map'
}
```

### 13.webpack优化

```
1.优化loader,如果loader很多会导致每个文件都会去匹配一次,使用oneOf
2.打包的时候给打包后的文件名后面加上contenthash值(只有文件内容改变了这个才变),这样可以避免浏览器的强制缓存导致文件改变失效，同时如果只是使用hash或者chunkhash,会导致只要有一个文件修改，其他文件名也会被一并修改。
3.tree shaking技术，去除工程中无用的代码(必须使用ES6模块化，开启production环境就会自动开启)
4.code split技术
```

### 14 TCP三次握手、四次挥手++

<img src="../../AppData/Roaming/Typora/typora-user-images/image-20200723110350833.png" alt="image-20200723110350833" style="zoom:80%;" />

```
三次挥手(建立连接)
第一次：建立连接时，客户端发送SYN包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次：服务器收到SYN包，向客户端返回ACK（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RCVD状态；
第三次：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
完成三次握手，客户端与服务器开始传送数据，也就是ESTABLISHED状态。
(如果只进行两次握手，没有最后一次，设想这样一种情况。客户端第一次发送的连接请求由于网络原因没有按时到达服务器，于是客户端又重新发送了一次，服务器无法区分哪一个才是真正要建立连接的，会对两个都建立连接。造成资源浪费)
三次握手保证了不会建立无效的连接，从而浪费资源。



四次挥手(断开连接)
第一次： TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。
第二次：服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
第三次：服务器关闭客户端的连接，发送一个FIN给客户端。
第四次：客户端发回ACK报文确认，并将确认序号设置为收到序号加1。
(如果只进行三次挥手，没有最后一次，如果客户端不发送ACK信号，由于服务器没有收到，那么它隔一会会再次发送FIN，一直无法进入"关闭"状态)
```

### 15 进程和线程（3点）

```
1.在资源分配上，进程在执行过程中拥有独立的内存单元，多个线程共享内存
2.一个程序至少有一个进程,一个进程至少有一个线程，线程的划分尺度小于进程
3.线程不能够独立执行，必须依存于应用程序中

比如拿浏览器内核进程举例，其中包括多个线程:
1.渲染线程
2.js执行线程
3.事件触发线程(处理页面中的事件回调)
4.定时触发线程
5.异步http请求线程
```



### 16 哪些操作可以发起http请求（4点）

```
1.ajax
2.link标签 href属性
3.script标签 src属性
4.img标签 src属性
5.视频标签
```

### 17 websocket怎么建立

```
1.浏览器发送一个HTTP的GET请求到服务器，携带的头部包括：
Connection:Upgrade
Upgrade: websocket
Sec-WebSocket-Key: [16byte字符串]
Sec-WebSocket-Version:13

2.服务器收到这个请求，响应101，同时响应头部包括:
Connection:Upgrade
Sec-WebSocket-Accept:[从Sec-WebSocket-Key的值继承而来]
Upgrade:websocket

3.成功后连接变为websocket
```

### 18 vue的优缺点

```
优点
1.轻量级，数据双向绑定
2.组件化(提高开发效率，方便重复使用)
3.指令

缺点:
1.生态环境不如react
```

### 19 CommonJS和ES6区别

```
1.
CommonJS模块输出的是一个值的拷贝(如果内部改变了这个值，输出还是保持原来的)
ES6模块输出的是值的引用(只能读取，不能对其重新赋值)


2.CommonJS模块是运行时加载，ES6 模块是编译时输出接口

3.CommonJS导入支持动态导入require(`${path}/xx.js`)，ES6模块化导入不支持
```

### 20 利用promise发起一个接着一个相互依赖的请求 ++

![image-20200728143602603](../../AppData/Roaming/Typora/typora-user-images/image-20200728143602603.png)

```html
<script>
  function getData(url){//用来发起请求的函数
    let xhr = new XMLHttpRequest()
    return new Promise((res,rej) => {
      xhr.open('GET',url)
      xhr.send(null)
      xhr.onreadystatechange = function(){
        if(xhr.readyState === 4){
          if(xhr.status === 200){
            res(xhr.responseText)
          } else {
            rej(xhr.responseText)
          }     
        }
      }
    })
  }
</script>
<script>
  let api1 = 'http://www.dms.yuhualab.com:10086/eval/platform/device/count'
  let api2 = 'http://www.dms.yuhualab.com:10086/eval/platform/device/history_collection_time'
  //一个完了才能进行下一个请求
  getData(api1)
  .then((res) => {
    console.log(res)
    console.log('请求1已经结束')
    return getData(api2)
  })
  .then((res) => {
    console.log(res)
    console.log('请求2已经结束')
  })
</script>
```

### 21 利用promise发起并行请求

```html
<script>
  let api1 = 'http://www.dms.yuhualab.com:10086/eval/platform/device/count'
  let api2 = 'http://www.dms.yuhualab.com:10086/eval/platform/device/history_collection_time'
  //并行发送请求 全部都成功了才执行then函数
  Promise.all([getData(api1),getData(api2)]).then(([res1,res2]) => {
    console.log(res1)
    console.log(res2)
  })
</script>
```

```html
<script>
    let api1 = 'http://www.dms.yuhualab.com:10086/eval/platform/device/count'
    let api2 = 'http://www.dms.yuhualab.com:10086/eval/platform/device/history_collection_time'
    //并行发送请求 谁先到就响应谁 其中有请求出错就直接触发catch函数
    Promise.race([getData(api1),getData(api2)]).then(res => {
        console.log(res)
    })
</script>
```

### 21 利用promise让一个页面最多只能发起2个(n个)请求，等到2个请求响应完成后再继续

![image-20200812111834880](../../AppData/Roaming/Typora/typora-user-images/image-20200812111834880.png)

```html
<script>
  const MAX_REQUEST = 3 //最大发送的请求数目
  let apiArr = [ //页面请求的url
  'http://www.dms.yuhualab.com:10086/eval/platform/device/count',
  'http://www.dms.yuhualab.com:10086/eval/platform/device/history_collection_time',
  'http://www.dms.yuhualab.com:10086/eval/platform/device/count',
  'http://www.dms.yuhualab.com:10086/eval/platform/device/history_collection_time',
  'http://www.dms.yuhualab.com:10086/eval/platform/device/count',
  'http://www.dms.yuhualab.com:10086/eval/platform/device/history_collection_time',
  'http://www.dms.yuhualab.com:10086/eval/platform/device/count',
  ]

  function sendRequest(n){
    let reqArr = []
    while(n > 0){
      if(apiArr[0] === undefined){
        break
      }
      reqArr.push(apiArr.shift())
      n--
    }
    if(reqArr.length === 0){ //请求发送完毕 递归终止
      return
    }
    Promise.all(reqArr.map(url => getData(url))).then((resArr) => {
      resArr.forEach(res => {
        console.log(res)
      })
      sendRequest(MAX_REQUEST) //当前的请求响应成功后 递归调用
    })
  }
  sendRequest(MAX_REQUEST)
</script>
```



### 22 前端路由hash模式

```html
<body>
  <button id='page1'>#test1</button>
  <button id='page2'>#test2</button>
</body>
<script>
  let page1 = document.getElementById('page1')
  let page2 = document.getElementById('page2')
  let hash = '' //保存全局的hash值
  page1.addEventListener('click',function(e){
    hash = e.target.innerText
    location.hash = hash //更新全局hash值
  })
  page2.addEventListener('click',function(e){
    hash = e.target.innerText
    location.hash = hash //更新全局hash值
  })
  window.onhashchange = function(e){ //监听hashchange事件
    if(hash === '#test1'){
      //加载#test1的页面
      console.log('加载#test1的页面')
    } else if(hash === '#test2'){
      //加载#test2的页面
      console.log('加载#test2的页面')
    }
  }
</script>
```

### 23 前端路由history模式

```html
<body>
  <button id='page1'>/test1</button>
  <button id='page2'>/test2</button>
</body>
<script>
  let page1 = document.getElementById('page1')
  let page2 = document.getElementById('page2')
  let url = ''
  page1.addEventListener('click',function(e){
    url = e.target.innerText
    history.pushState({pageName:url},'',url)
  })
  page2.addEventListener('click',function(e){
    url = e.target.innerText
    history.pushState({pageName:url},'',url)
  })
  window.onpopstate = function(e){
    const page = e.state['pageName'] //拿到每个url的状态信息
    if(page === '/test1'){
      //加载test1页面
    } else if(page === '/test2'){
      //加载test2页面
    }
  }
</script>
```

### 24 浏览器的network有什么功能

```
network可以看到当前页面所有资源的加载信息，包括html文档 css js 图片 xhr等等，只要是当前页面使用的资源都可以在这看见。同时还可以了解每一个资源的基本信息(名称，状态，使用的协议，所在的域，大小，加载时间等)，也可以看见每一个资源的具体的HTTP请求和响应的内容信息，很方便开发者进行调试（比如查看有些资源是否没有加载等等）
```

### 25 浏览器中的进程和线程++

![image-20200801155805100](../../AppData/Roaming/Typora/typora-user-images/image-20200801155805100.png)

### 26 GET和POST的区别

```
1.GET请求会被浏览器主动缓存，POST不会，要手动设置
2.GET请求参数会被完整保留在浏览器历史记录里，POST中的参数不会
3.GET请求在URL中传送的参数是有长度限制的，而POST没有限制
4.GET参数通过URL传递，POST放在Request body中
```

### 27 HTTP1.1和HTTP2.0的区别

```
1 连接优化
a.http/1.0的时候，每进行一次http通信，都需要经历TCP连接 传输HTTP数据和断开TCP连接三个阶段
(因为当时每个页面引用的资源不多，文件也比较小)
b.http/1.1的时候，增加了持久连接，默认一个TCP连接建立后不会断开
(目前浏览器针对同一个域名，默认允许同时建立6个TCP持久连接)
c.http/1.1的时候，虽然持久连接可以减小TCP连接和断开的次数，但是同一个TCP连接中，只有等待上一个的响应回来后才能进行下一个http请求的发送.通过引入管线化的技术，可以在同一个TCP连接中一起发送HTTP请求，但是服务器仍然根据请求到达的顺序来进行回复
(但是浏览器不支持，opera支持？)
d.http/2.0的时候，虽然http/1.1增加了持久连接，但是会导致队头堵塞，http2.0引入多路复用，进行http请求的并行发送，每一个请求使用一个ID进行标识，相同的ID说明是同一个请求的内容，以方便服务器和浏览器识别
(多路复用的实现:使用二进制分帧生成ID)


2 解决TCP慢启动
http1.1默认每一个域可以建立6个TCP连接，而且每个TCP会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动(这个没有办法改变，是TCP本身的现状)。
并且当网络带宽不足的时候，建立过多的TCP连接的时候，每个连接会动态减慢接收数据的速度
http2.0默认一个域名只有一个TCP连接，这样只用进行一次慢启动，同时也避免了多个TCP连接竞争带宽所带来的问题

3 内容压缩
http2.0对HTTP请求的头部进行了压缩，可以减少传输的数据量
```

### 28 xhr的readystate数字的含义++

<img src="../../AppData/Roaming/Typora/typora-user-images/image-20200812115442268.png" alt="image-20200812115442268" style="zoom:80%;" />

| 值   | 含义                    | 说明                                         |
| ---- | ----------------------- | -------------------------------------------- |
| 0    | 未初始化(UNINITIALIZED) | 还没有调用open()方法                         |
| 1    | 启动(LOADING)           | 已经调用open()方法，但是还没有调用send()方法 |
| 2    | 发送(LOADED)            | 已经调用send()方法，但是还没有接收到响应     |
| 3    | 部分(INTERACTIVE)       | 已经接收到原始响应数据，但是没有进行解析     |
| 4    | 完成(COMPLETED)         | 已经全部解析完成，并且可以在客户端使用了     |

### 29 前端上传文件的方式

```
1. 通过form表单和input组合(设置form的aciton为后端页面api,enctype="multipart/form-data",type='post')

2. 利用js新建一个FormData()对象来上传

3. 使用h5提供的fileReader读取文件数据进行上传
```

### 30 HTML和XHTML的区别

```
Xhtml的语法较为严谨
1.XHTML所有标签都必须小写
2.XHTML标签必须成双成对，嵌套要正确
3.XHTML所有属性都必须使用双引号
4.XHTML标签名必须用小写字母
```

### 31 js不同循环之间的优缺点++

```js
//1. 常规for循环
//可以使用continue break return 跳出循环

//2. forEach循环
//不能使用continue,否则报错
//不能使用break,否则报错
//可以使用return跳过某一次循环，相当于continue的功能，但是不能break出去
let seq = [0,1,2,3,4,5,6]
seq.forEach((elm,idx) => {
  if(elm === 1){
    return
  }
  console.log(elm)
})// 0 2 3 4 5 6

//3. for of循环
//可以使用continue break return 跳出循环
//可以搭配解构赋值来遍历map set object
let obj1 = {a:'xsd',d:4}
for(let [key,value] of Object.entries(obj1)){
  console.log(`${key}:${value}`)
}

let set  = new Set([0,1,2,3])
for(let [key,value] of set.entries()){
  console.log(`${key}:${value}`)
}

//4. for in循环
//用于遍历对象的键
//可以使用continue break return 跳出循环

//5. every循环
//不能使用continue,否则报错
//不能使用break,否则报错
//可以使用return跳出循环 相当于break出去 但是跳出去后 整个every一定返回false
let seq = [0,1,2,3,4,5,6]
let res = seq.every((elm,idx) => { //res为false
  if(elm === 2){
    return
  }
  return elm < 9
})

//6. reduce循环
//不能使用continue,否则报错
//不能使用break,否则报错

//7. map循环
//不能使用continue,否则报错
//不能使用break,否则报错

//8. filter循环
//不能使用continue,否则报错
//不能使用break,否则报错
```

### 32 首页白屏的时间计算++

 ```
从浏览器发起请求到浏览器显示页面总共会经过以下几个阶段:
可以使用performance.timing对象里面的数据进行计算得出
1. DNS解析时间
2. TCP建立时间
3. 白屏时间
4. DOM渲染完成时间
5. 页面onload时间
 ```

| 阶段            | 说明 | 计算                                       |
| --------------- | ---- | ------------------------------------------ |
| DNS解析时间     |      | domainLookupEnd - domainLookupStart        |
| TCP建立时间     |      | connectEnd - connectStart                  |
| 白屏时间 ++     |      | responseStart - navigationStart            |
| DOM渲染完成时间 |      | domContentLoadedEventEnd - navigationStart |
| 页面onload时间  |      | loadEventEnd - navigationStart             |



## #.2 网上收集的

###  1 [html]  、HTML规范：文档声明头

* html文档声明决定了这篇文档所能使用的标签和相应的使用规则（比如能不能使用标签的大写形式）

```
html1 至 html3 是美国军方以及高等研究所用的，并未对外公开。

使用html5
<!DOCTYPE html>
使用HTML 4.01 Strict
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
使用HTML 4.01 Transitional
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
使用HTML 4.01 Frameset
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
```



### 2 [html] 、常见的行内元素，常见的块级元素

```
行内元素 
内容决定元素的宽高 不可以通过css改变宽高
line-height可以设置 padding左右(上下可以设置但是不会影响周围的元素) margin左右可以设置(上下设置了会被忽略) 其他方向设置没有效果
行内元素只能容纳文字或者其他行内元素
span a em strong

块级元素 
独占一行 可以通过css改变宽高
可以容纳任何元素
div h1-h6 p ul li ol form table

行内块元素
可以通过css改变宽高 不独占一行
img input button select
```



### 3 [html]  、行内元素和块级元素的区别，行内元素和块元素的转化

```
通过css的display属性进行转化
```



### 1  [css]、 如何脱离文档流

* 使用浮动  注意:浮动的盒子会覆盖在不浮动的盒子上面，但是盒子中的文字依然会环绕在浮动盒子的周围
* 使用定位 position fixed

### 2  [css]、定位的方式以及区别

```
一共有5种
static 默认
relative 相对定位的偏移参考元素是元素本身
absolute 以父辈元素中不为static定位的元素为参考,直到html元素
fixed 以浏览器可视窗口为参考
```



### 3  [css]、什么是BFC，触发BFC的条件（4点）

* BFC是块级作用域，形成BFC后，其内部的元素不会对外部的元素有任何影响，
* 形成条件
  * overflow不为visible的元素
  * 根元素，即HTML元素
  * 定位元素，position: fixed/absolute
  * 浮动元素，float 不为none
  * display的值为inline-block、table-cell、table-caption

### 4  [css]、清除浮动的方式

```
一共有四种
1.给父元素显式设置高度
2.给父元素添加overflow:hidden
3.给父元素添加一个空的div标签，设置clear:both
4.利用::after伪元素 content:'' display:block clear:both
```



### 5  [css]、CSS的盒模型，包括IE情况下的和标准的W3c，怎么改变盒子模型？

```
盒模型一共有两种
1.w3c
盒子宽度 = margin-left + border-width + padding-left + width + padding-right + border-width + margin-right
盒子高度 = margin-top + border-width + padding-top + height + padding-bottom + border-width + margin-bottom

2.IE
盒子宽度 = margin-left + width + margin-right
盒子宽度 = margin-top + height + margin-bottom

可以通过css属性box-sizing改变 content-box(W3C盒子) border-box(IE盒子)
```



### 6  [css]、css中的单位有哪些？区别是？

```
绝对单位
1英寸 = 2.54厘米
in(英寸) cm mm pt(点) px(像素,pc直接使用屏幕的像素)

相对单位
em(相对于父元素的字体大小)
rem(相对html元素中的字体大小)
ex
```



### 7  [css]、伪类和伪元素的区别？

```
伪元素
可以在dom中插入元素
::first-line
::first-letter
::before
::after

伪类
不能插入元素
```



### 8  [css]、水平居中的方式，垂直居中的方式

```
针对行内元素 行内块元素
水平居中 在其父元素上设置text-align:center
垂直居中 在文本标签上设置line-height:父元素高度

针对块级元素
水平居中 margin:0 auto 
垂直居中 绝对定位+margin(元素宽高已知，不好)，弹性布局，transform属性+绝对定位(更好)
```



### 9  [css]、css中的权重

```
Infinity !important
1000     行内样式 
0100     id选择器 
0010     class选择器 属性选择器 伪类选择器
0001     标签选择器 伪元素选择
0000     通配符
无       继承而来的css属性

如
0001   h1 {}   
0002   p em {}
0022   p.bright em.dark {}
0111   div#sidebar *[href] {}
```



### 10[css]、css中的各种选择器

```
基本选择器
ID 类 标签

修饰选择器(不能独立存在)
属性选择器 伪类选择器 伪元素选择器

文档结构选择器
父子选择器(>) 后代选择器(空格 紧邻同胞(+) 后续同胞(~)
```



### 11[css]、css3新增属性

```
border-image
border-radius
box-shadow

background-size
background-origin
background-clip 背景是否覆盖边框 内边距

text-shadow
text-overflow

transform变换效果
animation动画效果

transition过渡效果
```



### 12[css]，说一下flex布局

### 13[css]、浏览器是怎么解析css选择器的？

### 14[css]、css3中的动画

### 15[css]、两个重要的布局：a圣杯布局b左列定宽，右列自适应

### 16[css]、什么是响应式开发

### 17[css]、简单说一下轮播图（有js部分）

### 18[css]、让一个元素消失的方法

### 1 [js]、js原生常用的API，主要是对字符串和数组的操作方法

### 2 [js]、运算符\==和\===的区别，轻质类型的转换"0"和“undefined”，

### 3 [js]、js的基本类型有哪些，引用类型有哪些？本质区别是什么？

### 4 [js]、js变量，变量提升（与ES6的区别）

### 5 [js]、js函数，函数作用域、原型链

### 6 [js]、闭包，闭包的概念，作用，坏处

### 7 [js]、事件对象和冒泡、事件委托，好处

### 8 [js]、深拷贝和浅拷贝，

### 9 [js]、js里面的继承问题，构造函数的继承，原型链的继承，组合继承

### 10[js]、判断js类型的方法，typeof和instanceof以及原型链判断

### 11[js]、正则表达式，典型的判断电话号，判断邮箱格式

### 12[js]、this的指向

### 14[js]、实现tab栏的切换，实现拖拽，实现匀速动画

### 15[js]、new操作符具体干了什么，

### 16[js]、通过js获取节点属性，以及对节点的操作

### 17[js]、call、bind、apply

### 19[js]，js加载方式，放在头部和</body>之前的区别，

### 20[js]、window.onload和window.onready的区别

### 21[js]、事件绑定的方式

### 1 [net]、同源策略，为什么跨域，跨域的方式，最爱问jsonp

### 2 [net]、http请求的方式，状态码，常用的请求头和响应头

### 3 [net]、页面输入一个url加载的过程

### 4 [net]、浏览器缓存的方式

### 5 [net]、页面性能优化的方式

### 6 [net]、图片优化的方式

### 7 [net]、如何减少重绘和重排

### 8 [net]、前后端的数据存储

### 9 [net]、webpack

### 10[net]、osi七层模型

### 1 [program]、数组去重

### 2 [program]、打印三角形

### 4 [program]、字符串翻转

### 5 [program]、排序：冒泡排序、快排

### 6 [program]、判断小括号是否闭合

### 7 [program]、分解合数为质数

### 8 [program]、数制的装换

### 9 [program]、将字符串转换为驼峰

### 10[program]、获取

## #.3 字节跳动

### 1 深拷贝，浅拷贝 （JSON.stringify的缺陷， Date 对象， Symbol, RegExp）

* 深、浅拷贝的区别在于是否真的获取了一个对象的复制实体，而不是它的引用。深拷贝在计算机中开辟了一块内存地址用于存放复制的对象，而浅拷贝仅仅是指向被拷贝的内存地址，如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应改变。

* 深拷贝实现

  ```js
  //1.利用JSON.parse(JSON.stringify()) 但是不能拷贝正则 undefined 函数 相互引用的对象
  //2.使用递归
  function deepCopy(obj) {
      let objClone = Array.isArray(obj) ? [] : {};
      if (obj && typeof obj === 'object') {
          for (const key in obj) {
              //判断obj子元素是否为对象，如果是，递归复制
              if (obj[key] && typeof obj[key] === "object") {
                  objClone[key] = deepCopy(obj[key]);
              } else {
                  //如果不是，简单复制
                  objClone[key] = obj[key];
              }
          }
      }
      return objClone;
  }
  ```

* 浅拷贝

  ```js
  //1.如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性
  object.assign(target,source) //这样会使target中包含source的值
  
  //2.直接使用等号
  ```

### 2 两边固定，中间自适应（越多越好 3点）

* flex布局，父元素使用flex，第一个div和第三个div的宽度固定，第二个div的flex为1
* 利用浮动，第一个div和第二个div的分别左右浮动，第三个div正常(但是要设置左右外边距将浮动元素的空间留出来)
* 利用绝对定位，center的div水平居中(margin:0 200px),200px为左右盒子的宽度，左右盒子进行绝对定位

### 3 跨域++

```
在互联网上，所有的资源都可以由URL唯一指定，不同源的条件:
1.两个资源所在服务器地址不一样(子域名和父域也形成跨域 )
2.两个资源所使用的通信协议不一样
3.两个资源的端口号不一样
满足其中一个，这两个资源就是跨域资源，那么这两个资源的相互访问就会受到浏览器对于跨域资源访问的限制，有两种方法可以避免：

第一种:使用CORS标准政策
该方法需要前后端对HTTP请求头做一些处理，详细见17题

第二种:使用jsonp方式(只能用于get请求)

第三周:使用nginx进行反向代理，首先将nginx服务器部署在和后台同一个域中, 
```

```js
//比如请求的接口为http://freegeoip.net/json/?callback=handleResponse
//其返回数据的格式为 handleResponse("{data:12}")
function jsonp(url){
    //在全局注册一个函数，该函数的函数名需要和后端约定好,本例子的函数名为handleResponse
    window['handleResponse'] = function(result){
        console.log(result) //打印收到的结果 为{data:12}
        document.body.removeChild(scriptJsonp)  
    }
    let scriptJsonp = document.createElement('script')
    script.src = url
    document.body.appendChild(scriptJsonp) 
}
```



### 4 script解析过程

### 5 diff算法

* 宽度优先算法BFS

  ```js
  //首先明确一点，虚拟DOM可以看成是一颗多叉树
  ```

### 6 缓存，强制缓存，协商缓存，有实际用过吗？

```
参考HTTP笔记的第九节
```

### 7 http网络请求过程[从url输入到服务器的过程]

* 1.域名解析

  ```
  (1).浏览器会首先搜索浏览器自身的DNS缓存（可以使用 chrome://net-internals/#dns 来进行查看）
  (2).如果(1)中未找到，那么Chrome会搜索操作系统自身的DNS缓存（可以在命令行下使用 ipconfig /displaydns 查看）。如果找到且没有过期则成功。
  (3).如果(2)中未找到，那么尝试读取位于C:\Windows\System32\drivers\etc下的hosts文件，如果找到对应的IP地址则解析成功。
  (4).如果(3)中未找到，浏览器首先会找TCP/IP参数中设置的本地DNS服务器，如果要查询的域名包含在本地配置的区域资源中，则完成域名解析，否则根据本地DNS服务器会请求根DNS服务器。
  (5).本地DNS会把请求发至13台根DNS,直到找到为止。
  ```

* 2.TCP的三次握手

  ```
  syn 同步序列编号（Synchronize Sequence Numbers）
  客户端发起syn (服务器在吗，我想建立连接,我发送的数据包以seq=a开始编号) 服务器知道客户端可以发
  服务端响应ack,syn (收到(ack=a+1)，在的。我发送的数据包以seq=b开始编号) 客户端知道服务器能发和收
  客户端回复ack (好的。)  服务器知道客户端能收
  
  如果进行两次握手，那么服务器发送完ack,syn之后,客户端就认为连接已经建立了，但是会出现以下情况：
  1.服务器不知道客户端是否准备好，将会把客户端发来的报文忽略，客户端由于没有得到响应，以后超时，会进行重发，大大浪费网络资源
  ```

* 3.建立TCP连接后发起HTTP请求

  ```
  服务器响应HTTP请求
  ```

* 4.断开连接 TCP四次挥手(两边都可以发起断开信号)

  ```
  客户端发起FIN(我不发数据了，停止TCP连接，FIN置1)
  服务器响应ACK(收到了，等我把剩下的数据处理完，将ACK置1)
  服务端回复FIN(我剩下的数据发完了，将FIN置1)
  客户端回复ACK(收到，将ACK置1)
  ```

如果进行三次挥手(即第二个和第三个合并),那么会导致服务器要传给客户端的数据丢失
### 8 图片懒加载（原理，什么时候加载，如果是监听滚动，滚动会触发很多次，怎么优化）

```
参考#.1中的第6题
```



### 9 大文件按需切片上传？断点续传和秒传？(问的很细，hash值怎么取，md5怎么加密，大文件加密很慢怎么办？)

### 10 水平垂直居中的方式(5种?)

* 使用绝对定位+margin(针对定位元素宽高已知)
* 使用绝对定位+calc()函数(针对定位元素宽高已知)
* 使用绝对定位+transform(针对定位元素宽高未知)
* 父元素text-align:center 子元素display:inline-block lineheight为父元素的高
* 适用弹性布局(justify-content align-items)

### 11 说一说前端体系++

```
从发展历史大概说一说
```



### 12 Object.defineProperty本质有很多可配置的选项，说一下有什么可配置的选项？

```
一共有四种
1.writable 是否可写        决定是否可以修改属性的值
2.enumerable 是否可以枚举   决定是否可以枚举，在循环中出现
3.configurable 是否可以配置  决定是否可以delete这个属性 ，是否可以进行重新配置
4.value 值
5.get() getter获取值的时候触发
6.set() 定义值的时候触发
```

### 13 v-model是怎么实现双向绑定的

* vue本身的数据流是单向的，即数据层的改变会自动触发视图层的更新，常见的插值形式{{ data }}和v-bind都是单向绑定的
* 但是通过v-model是可以实现数据的双向流动,v-model是一个语法糖

```html
<input v-model='username'/>

首先将input上的value属性绑定到数据层中的username 本质通过Object.defineProperty()
然后将

<input :value='username' @input='val => username = val'/>
```

### 14 vue的响应式是怎么实现的

* 最好举例说明

```js
主要使用Object.defineProperty()

let data = {}
//input.addEventListener('input',function(e){
     // let val = e.target.value
     // data['a'] = val//当input发生改变的时候，同时改变data的值 
//})
      
Object.defineProperty(data,'a',{
    get(){
        return a
    },
    set(val){//当data发生改变的时候，同时改变视图input的值 
        a = val
        input.value = val
    }
})
```

### 15 对于一个行内元素，设置它的margin会有什么表现，为什么它是可行的

### 16 计算dom树中有某标签有多少个

```js
const foo = (root,tagName) => {
 
}
 
foo(document,'div') // 20
 
foo(document,'a') // 5
 
foo(document)

//层级搜索DOM树 BFS
const foo = function(document,tagName){
  let count = 0
  let quene = []
  quene.push(document)
  while(quene.length > 0){
    let now = quene.shift()
    if(tagName){
      now.nodeName.toLowerCase() === tagName ? count++ : ''
    } else {
      count++
    }
    quene.push(...now.children)
  }
  console.log(count)
  return count
}

foo(document)
```

### 17 options请求什么时候用

```
1.用于判断服务器支持的HTTP请求方法

2.cors的非简单请求时候用
```



### 18 简单请求和复杂请求

* 这两种请求是针对"跨域资源共享" CORS的情况下出现的

* CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

  整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

  因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

```
简单请求
HEAD
GET
POST
其请求头信息不超出以下几种字段
Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

对于简单请求的跨域，浏览器直接发出HTTP请求，如果浏览器发现是跨域的会自动在头信息中增加一个Origin字段，服务器收到这个请求会出现以下两种情况：
1.响应头中没有Access-Control-Allow-Origin字段或者有这个字段但是该字段的值没有包含Origin字段的值，那么浏览器收到这个响应过后直接报错，即使状态码为200
2.响应头中有Access-Control-Allow-Origin字段并且其值也正确，那么浏览器可以正常收到响应
```

```
非简单请求，满足三个条件之一
1.PUT，DELETE 2.包含自定义的头部字段 3.客户端要发送数据为json格式(接收json数据不是啊!!!)

对于非简单请求的跨域，浏览器在正式通信之前会增加一次“预请求”,即options请求
在这个请求头中，除了包含origin字段,还会至少包括以下两个特殊字段
Access-Control-Request-Method:列出浏览器的CORS请求会用到哪些HTTP方法
Access-Control-Request-Headers:该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段
比如在“消防项目”中:
Host: www.zhxf.yuhualab.com:8080 请求的服务器地址
Origin: https://www.zhxf.yuhualab.com 默认是80端口    注意Host和Origin的端口号不一样，所以这是跨域请求
Access-Control-Request-Headers: token 我们使用在get请求中使用了token这个字段
Access-Control-Request-Method: GET
Access-Control-Max-Age:1728000(单位秒，在该时间内不需要在进行预检请求)


Access-Control-Request-Headers: content-type
Access-Control-Request-Method: POST
Origin: https://www.zhxf.yuhualab.com

服务器收到请求，就会做出响应，比如在“消防项目”中：
Access-Control-Allow-Headers: token //允许这个token头部的使用
Access-Control-Allow-Methods: GET //允许这个token头部的使用的方法为get
Access-Control-Allow-Origin: * //允许来自所有源的请求
```

### 19 tcp和udp的区别(4点)，应用场景

```
见第一节
```

### 20 编程题：实现一个chain, eat函数打印eat，work函数打印work，sleep函数休息

```js
chain().eat().sleep(5).work().eat().work().sleep(10)

//使用循环阻塞主线程 [不好]
function chain(){
  return {
    eat(){
      console.log('eat')
      return this
    },
    work(){
      console.log('work')
      return this
    },
    sleep(time){
      let start = (new Date()).getTime()
      while((new Date()).getTime() - start <= time*1000){
        continue
      }
      return this
    }
  }
}

chain().eat().sleep(1).work().eat().sleep(3).eat()

//使用promise实现
function Chain(){
  this.promise = Promise.resolve() //一个状态为resolved的promise对象
}

Chain.prototype.eat = function(){
  this.promise = this.promise.then(() => {
    return new Promise((res) => {
      console.log('eat')//新建promise对象的时候，会立即执行
      res()//将新的promise对象变为resolved状态，不然不能执行then()中的回调函数
    })
  })
  return this
}

Chain.prototype.work = function(){
  this.promise = this.promise.then(() => {
    return new Promise((res) => {
      console.log('work')
      res()//将新的promise对象变为resolved状态，不然不能执行then()中的回调函数
    })
  })
  return this
}

Chain.prototype.sleep = function(time){
  this.promise = this.promise.then(() => {
    return new Promise((res) => {
      setTimeout(() => {
        res()//将新的promise对象变为resolved状态，不然不能执行then()中的回调函数
      }, time*1000);
    })
  })
  return this
}

function chain(){
  return new Chain()
}
```

### 21 说一下前端的发展 ++

```
1.跨多端的方向，虽然现在混合APP可以横跨多端，但是相比于原生的APP,性能肯定是要打折扣的。未来性能的优化是一个发展方向。
2.现在前端开发基本都被三大框架占据，可以预想在未来基本也是这样，即使某一个框架被淘汰，相信也会有新的框架出现。随着项目越来越复杂，工程化和模块化是不可避免的。但是这样也有弊端，这些框架和模块屏蔽了底层细节，虽然可以很大程度上方便开发人员，但是也让开发人员很难去找到错误点和实现更个性化的东西。所以未来对于前端的开发人员来说，要始终保存学习

```



### 22 cookie可以设置哪些属性，前端怎么获取cookie，前端可以设置哪些属性

```
浏览器本地怎么才能存放cookie，当使用浏览器取访问某个特定的web站点的时候，其响应头如果包括Set-Cookie，那么就会让浏览器在本地存储cookie,比如:
Set-Cookie: "name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure"


这里涉及到一个问题，是不是每个请求我们都会带上所有的 cookie，显然不是的，要不性能就会十分低下了。那么浏览器是根据什么判别哪些请求会带上哪些 cookie 呢？

这就跟 Domain 和 path 属性息息相关了

比如，现在一个 cookie 它的 Domain 属性为 www.example.com，path 属性值为 /。意味着，这个 cookie 对该域的根路径以及它的所有子路径都有效。如果我们修改了它的 path 值，为 /forums，那么这个 cookie 只要在访问 www.example.com/forums 及其子路径时才会带上。(这个是浏览器自动带上的)
```

```
通过系统的document.cookie可以获取当前页面下的cookie

name (前端可以设置)
value (前端可以设置)
domain (前端可以设置)
path (前端可以设置)
max-age/expire (前端可以设置)
httpOnly
samesite(有些浏览器支持,可以指定在何种情况发送cookie)
secure
```

```js
//前端修改cookie
document.cookie = 'id=123424;expires=2020,xxx'
```



### 23 编程题：sum(1)(2)(3).value() // 6

```js
const sum = function(...args){
  let totalArgs = args//形成闭包，存放所有的参数

  function reply(...args){
    totalArgs = totalArgs.concat(args) //将所有的参数进行组合
    return reply
  }

  reply.value = function(){
    let res = totalArgs.reduce((pre,cur) => {
      return pre + cur
    },0)
    console.log(res)
    return res
  }

  return reply
}
sum(1)(2,3,4)(3,6,10).value()  //29

//其他
const sum = function(...args){
  let totalArgs = args
  return function reply(...args){
    totalArgs = totalArgs.concat(args) //将所有的参数进行组合

    if(args.length === 0){ //递归截止,对所有的参数进行处理
      let res = totalArgs.reduce((pre,cur) => {
        return pre + cur
      },0)
      return res
    } else {
      return reply
    }
  }  
}
sum(1)(2,3,4)(3,6,10)() //29
```

### 24 webpack怎么打包？为什么用？怎么配置？

### 25 普通函数和箭头的函数的差别（6点）

```
1.箭头函数更简洁
2.箭头没有this(捕获其所在的上下文的this,作为自己的this值)
3.箭头函数不能使用new
4.不绑定arguments
5.箭头函数没有原型属性
6.箭头函数不能使用call() apply()
```

### 26 写一个闭包的例子

```js
let temp = 'outer hello'
function outer(){
    let temp = 'inner hello'
    function inner(){
       console.log(temp) 
    }
    return inner
}
let func = outer()
func() // 'inner hello'
```



### 27 手写定时器每隔两秒输出1,2,3,4(会使用闭包)

```js
function test(){
  let value = 1
  let timer;
  timer = setInterval(() => {
    if(value === 5){
      clearInterval(timer)
    } else {
      console.log(value)
      value++
    }
  }, 2000);
}
```

### 28 写一个继承

### 29 判断两个对象是否相等(里面都是简单数据)

```js
//只嵌套一层
function isObjEqual(obj1,obj2){
    const isType = Object.prototype.toString
    if(isType.call(obj1) !== '[object Object]' || isType.call(obj2) !== '[object Object]'){
        return false
    }
    for(const key in obj1){
        if(obj2[key] && obj2[key] === obj1[key]){
            continue
        } else {
            return false
        }
    }
    return true
}

//嵌套多层
function isObjEqual(obj1,obj2){
  const isType = Object.prototype.toString
  const keys1 = Object.keys(obj1)
  const keys2 = Object.keys(obj2)
  if(keys1.length !== keys2.length){
    return false
  }
  for(const key in obj1){
    if(isType.call(obj1[key]) === '[object Object]'){
      if(obj2[key] && isType.call(obj2[key]) === '[object Object]'){
        if(!isObjEqual(obj1[key],obj2[key])){
          return false
        }
      } else {
        return false
      }
    } else {
      if(obj2[key] && obj2[key] === obj1[key]){
        continue
      } else {
        return false
      }
    }
  }
  return true
}

//最直接 也有很多缺点
function isObjEqual(obj1,obj2){
  return JSON.stringify(obj1) === JSON.stringify(obj2)
}
```

### 30 说一下MVVM模式，Vue数据绑定，Object.defineProperty()和proxy的区别

### 31 localStorage 、cookie、sessionStorage的区别(3点)

```
见第一节
```



### 32 版本号排序

```
var versions=['1.45.0','1.5','6','3.3.3.3.3.3.3'] 要求从小到大排序，注意'1.45'比'1.5'大
var sorted=['1.5','1.45.0','3.3.3.3.3.3','6']
```

```js
//leecode题目165
var compareVersion = function(version1, version2) {
  let arr1 = version1.split('.').map(ele => parseInt(ele))
  let arr2 = version2.split('.').map(ele => parseInt(ele))
  let len = Math.max(arr1.length,arr2.length)
  for(let i=0;i<len;i++){
      if(arr1[i] === undefined){
          arr1[i] = 0
      }
      if(arr2[i] === undefined){
          arr2[i] = 0
      }
      if(arr1[i] < arr2[i]){
          return -1
      } else if(arr1[i] > arr2[i]){
          return 1
      } else {
          continue
      }
  }
  return 0
};
let test = ['1.45.0','1.5','6','3.3.3.3.3.3.3']
test.sort(compareVersion)
console.log(test)
```

## #.3 腾讯

![image-20200811172720080](../../AppData/Roaming/Typora/typora-user-images/image-20200811172720080.png)

![image-20200811172736126](../../AppData/Roaming/Typora/typora-user-images/image-20200811172736126.png)

![image-20200811172753502](../../AppData/Roaming/Typora/typora-user-images/image-20200811172753502.png)

### 1.canvas常用方法（绘制矩阵、绘制圆、更改字体）



### 2.symbol里面传123，还有一个也传123，那他们两个相等吗

```
不等 symbol一旦创建就独一无二
```

### 3.promise里面new Error()，用try catch可以捕获吗？



### 4.页面加载前的白屏怎么处理？



### 5.怎么计算页面加载延时？



### 6.有一个项目代码特别多，怎么优化性能？



### 7.项目加载很慢，而且有一些功能最开始用不到，怎么解决这个问题?



### 8.如何上传文件?

### 9.TCP怎么解决丢包问题

### 10.如何实现一次CSRF攻击

## #.4 代码题

### 1 写一个事件队列

```js
function Quene(){
  this.delay = 0
  this.taskQuene = []
}

Quene.prototype.task = function(delay,cb){
  this.delay += delay
  this.taskQuene.push([cb,this.delay])
  return this
}

Quene.prototype.start = function(){
  while(this.taskQuene.length > 0){
    let taskNow = this.taskQuene.shift()
    setTimeout(taskNow[0],taskNow[1])
  }
}

new Quene()
.task(1000,() => {
  console.log(1)
})
.task(3000,() => {
  console.log(2)
})
.start()
// 1 2
```

### 2 写一个sleep函数

```js
//使用循环阻塞主线程
function chain(){
  return {
    eat(){
      console.log('eat')
      return this
    },
    work(){
      console.log('work')
      return this
    },
    sleep(time){
      let start = (new Date()).getTime()
      while((new Date()).getTime() - start <= time*1000){
        continue
      }
      return this
    }
  }
}

chain().eat().sleep(1).work().eat().sleep(3).eat()
```

### 3 数组去重

```js
function unique(arr){
  let set = new Set()
  for(let v of arr){
    if(!set.has(v)){
      set.add(v)
    }
  }
  return Array.from(set)
}
```

### 4 对比两个对象是否相等

```js
function isObjEqual(obj1,obj2){
  const isType = Object.prototype.toString
  if(Object.keys(obj1).length !== Object.keys(obj2).length){
    return false
  }
  for(const key in obj1){
    if(isType.call(obj1[key]) === '[object Object]'){
      if(obj2[key]){
        if(isType.call(obj2[key]) === '[object Object]'){
          if(!isObjEqual(obj1[key],obj2[key])){
            return false
          }
        } else {
          return false
        }
      } else {
        return false
      }
    } else {
      if(obj1[key] !== obj2[key]){
        return false
      }
    }
  }
  return true
}

//vue-router源码判断两个对象是否相等
function isObjectEqual (a, b) {
  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false
  }
  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key];
    // check nested equality
    if (typeof aVal === 'object' && typeof bVal === 'object') {
      return isObjectEqual(aVal, bVal)
    }
    return String(aVal) === String(bVal)
  })
}
```

### 5 依次去除字符串中重复的字符

```js
function duplicateChar(str){
  console.log(str)
  let repeatCharReg = /(\w)\1+/g  //正则表达式用于检测字符串中是否含有重复的字符
  if(!repeatCharReg.test(str)){
    return
  }
  return duplicateChar(str.replace(repeatCharReg,'')) //把重复的字符全部去掉，一个也不保留
}
duplicateChar('abbbaca') //依次打印 abbbaca aaca ca
```

### 6 合并两个排序的数组

```js
//不使用额外空间 利用插入排序的原理 [这个方法不好]
function mergeArr(sortedArr1,sortedArr2){
  let len1 = sortedArr1.length
  let len2 = sortedArr2.length
  sortedArr1.push(...sortedArr2)
  for(let i=len1;i<len2+len1;i++){
    for(let j=i;j>0;j--){
      if(sortedArr1[j-1] > sortedArr1[j]){
        [sortedArr1[j-1],sortedArr1[j]] = [sortedArr1[j],sortedArr1[j-1]]
      } else {
        break
      }
    }  
  }
  console.log(sortedArr1)
}
```

### 7 手写new的过程

```js
function myNew(){
    let this = {
        __proto__:myNew.prototype
    }
    this.name = 'xxxx'
    this.age = '24'
    return this
}
```

### 8 封装localstorage，让其在指定的时间失效

```js
let storage = {
    setItem(name,value,expireTime){
        let valObj = {
            value:value,
            createTime:(new Date()).getTime()
            expire:expireTime
        }
        localStorage.setItem(name,JSON.stringify(valObj))
    },
    getItem(name){
        let valObj = localStorage.getItem(name)
        let timeNow = (new Date()).getTime()
        if(timeNow - valObj['createTime'] > valObj['expire']){
            localStorage.removeItem(name)
            return null
        } else {
            return valObj['value']
        }
    }
}
```

### 9 寻找两个dom元素的第一个父元素

```js
function firstParent(elm1,elm2){
    while(elm1.parentElement){
        if(elm1.parentElement.contains(elm2)){
            return elm1.parentElement
        }
        elm1 = elm1.parentElement
    }
    return null
}
```

### 10 实现一个repeat方法

```js
// function repeat(func, times, wait) {} 返回一个函数

function repeat(cb,times,wait){
  let count = 0
  let timer;
  return function(val){
    timer = setInterval(() => {
      count++
      if(count > times){
        clearInterval(timer)
      } else {
        cb(val)
      }
      
    },wait)
  }
}
let repeatFunc = repeat(console.log,4,1000)
repeatFunc('hello world')
```

### 11 合并url

```js
/*
resolve('http://www.baidu.com', 'a/b/c'); -> http://www.baidu.com/a/b/c
resolve('http://www.baidu.com', 'a/../c'); -> http://www.baidu.com/c
resolve('http://www.baidu.com/1/2', 'a/.././c'); -> http://www.baidu.com/1/2/c
*/

function resolve(base,url){
  let str = base + '/' + url
  let baseUrlReg = /^.*com/
  let urlReg = /(?<=com).*/

  url = str.match(urlReg)[0]
  base = str.match(baseUrlReg)[0]
  let arr = url.split('/')
  let stack = []
  for(let v of arr){
    if(v === '' || v === '.'){
      continue
    } else if(v === '..'){
      stack.pop()
    } else {
      stack.push(v)
    }
  }
  url = '/' + stack.join('/')
  console.log(base + url)
}
```

### 12 数字千分位[正则表达式向前向后搜索的应用]

```js
let num = '123456789'
function thousandth(num){
  let reg = /(?<=\B)(?=(\d{3})+$)/g
  let str = num.replace(reg,',')
  console.log(str)
}
thousandth(num) //123,456,789
```

### 13 手写Promise.race()

```js
//输入一个promise对象组成的数组
//返回一个promise对象
Promise.myRace = function(arr){
    let len = arr.length
    return new Promise((res,rej) => {
        for(let i=0;i<len;i++){
            if(!(arr[i] instanceof Promise)){
                Promise.resolve(arr[i]).then(res,rej)
            } else {
                //只要数组中有一个promise对象变为fulfill状态，那么就让这个返回的promise对象状态变为fulfill状态
            	arr[i].then((r) => res(r),rej) 
            }
        }
    })
}
```

### 14 手写Promise.all()

```js
//输入一个promise对象组成的数组
//返回一个promise对象
Promise.myAll = function(arr){
    let count = 0
    return new Promise((res,rej) => {
        let ans = [] //用来存放结果
        for(let i=0;i<arr.length;i++){
            arr[i].then((r) => {
                count++
                ans[i] = r
                if(count === arr.length){//只有所有的promise状态变为fulfill才能让输入的状态变为fulfill
                    res(ans)
                }
            }).catch((e) => {
                rej(e)
            })
        }
    })
}
```

### 15 解析一个项目依赖文件[腾讯]

```js
var tree2 = {
    name: "page.js",
    require: [
        {
            name: "A.js",
            require: [
                {
                    name: "B.js",
                    require: [
                        {
                            name: "C.js",
                        },
                    ],
                },
            ],
        },
        {
            name: "D.js",
            require: [
                {
                    name: "C.js",
                },
                {
                    name: "E.js",
                },
            ],
        },
    ],
};

//bfs
function solve(tree){
  let queue = []
  let ans = []
  queue.push(tree)
  while(queue.length > 0){
    let now = queue.shift()
    if(!ans.includes(now['name'])){
      ans.push(now['name'])
      if(now['require']){
        queue.push(...now['require'])
      }
      
    }
  }
  return ans.reverse()
}
console.log(solve(tree)) //[ 'E.js', 'C.js', 'B.js', 'D.js', 'A.js', 'page.js' ]
```

### 16 两个排序数组的交集

```js
//交集
function intersection(arr1,arr2){
  let len1 = arr1.length
  let len2 = arr2.length
  let ans = []
  let i = 0,j=0
  while(i < len1 && j < len2){
    while(arr1[i] === arr1[i+1]){//跳过重复值
      i++
    }
    while(arr2[j] === arr2[j+1]){//跳过重复值
      j++
    }
    if(arr1[i] < arr2[j]){
      i++
    } else if(arr1[i] > arr2[j]){
      j++
    } else {
      ans.push(arr1[i])
      i++
      j++
    }
  }
  return ans
}
```

### 17 将对象序列化为url参数

```js
function stringifyUrl(obj = {}){
    let entries = Object.entries(obj)
    let ans = '?'
    for(let [key,val] of entries){
        //使用encodeURIComponent()可以对;/?:@&=+$这些在url中有明确含义的字符进行编码为十六进制
        ans = ans + `${key}=${encodeURIComponent(val)}&` 
    }
    return ans.slice(0,-1)
}
console.log(stringifyUrl({a:'xsd',d:4})) //?a=xsd&d=4
```

### 18 将url参数提取为对象

```js
function parseUrl(url){
    let ans = {}
    url.replace(/(^\?)|(&$)/g,'').split('&').forEach(elm => {
        const [key,val] = elm.split('=')
        //使用decodeURIComponent()可以对编码后的url字符进行解码
        ans[key] = decodeURIComponent(val)
    })
    return ans
}
```



## #.5 项目

```
项目中遇到的问题:
1.ajax请求接口地址管理混乱，一旦接口地址出现变动，就不得不在整个工程项目中取寻找
解决：把所有的接口地址放到单独的文件中，然后将这个对象挂载到vue的原型对象上

2.请求数据在发送前 响应数据在接收到后的逻辑处理重复
解决：使用axios请求拦截器(对于delete请求作出弹窗提示)和axios响应拦截器(对于put请求作出修改成功弹窗提示)

3.css样式代码组织混乱
解决：按照不同的类型，将css样式拆分成一个一个小文件(比如表单 按钮 表格 布局 容器等)
```



### 1 智慧消防设备管理系统

```
亮点：
1.token登录验证 接口验证 跨域解决
2.SPA应用 前端路由
3.数据定时更新


系统中填的:
该项目的研究对象是悬挂式的粉末灭火器罐，传统的这类灭火器罐主要有几个痛点：一是无法提前预知罐中粉末是否结块（这样会使其失去效果），二是随着时间的推移，罐中压强可能会下降，影响灭火的效果，三是厂商在面对罐子失效的情况下，无法及时的进行更换。基于此，我们设计了一套集压强，温度，湿度参数监测和报警的消防设备管理系统。我主要是负责前端界面的设计和开发。其中包括：完成“登录”界面的设计，并且能够和后端服务器完成登录验证，同时利用token 完成所有接口的验证；完成“首页”设计，利用 echarts 和 vue-baidu-map 库完成地图和统计图表的设计， 数据主要利用 axios 发起 ajax 请求； 完成 “信息” 录入界面，设计并完成增、改消防设备信息表单。目前已经实现功能包括：
1.针对客户信息的增删改查以及客户的位置定位
2.针对客户中所有的灭火设备信息的增删改查
3.灭火罐的历史数据（过去十天以内的温度，压强，每小时更新一次）的查看
4.针对设备报警的实时提示(开始使用websocket，后来改用轮询)
5.接着就是一些统计信息，比如每月新增客户，新增设备的统计；所有设备的在线离线统计；有效设备和无效设备的统计等
该项目已上线，地址www.zhxf.yuhualab.com



项目简介：
首先明确该项目的对象是悬挂式的粉末灭火器罐，传统的这类灭火器罐主要有几个痛点：一是无法提前预知罐中粉末是否结块（这样会使其失去效果），二是随着时间的推移，罐中压强可能会下降，影响灭火的效果，三是厂商在面对罐子失效的情况下，无法及时的进行更换。基于此，我们设计了一套集压强，温度，湿度参数监测和报警的消防设备管理系统。我主要是负责前端界面的设计和开发。

主要职责:
负责系统dashboard的设计和开发，其中包括：完成“登录”界面的设计，并且能够和后端服务器完成登录验证，同时利用token 完成所有接口的验证；完成“首页”设计，利用 echarts 和 vue-baidu-map 库完成地图和统计图表的设计， 数据主要利用 axios 发起 ajax 请求； 完成 “信息” 录入界面，设计并完成增、改消防设备信息表单。


目前已经实现功能包括 
1.针对客户信息的增删改查以及客户的位置定位
2.针对客户中所有的灭火设备信息的增删改查，以及每一台设备的监控数据的查看，历史数据（过去十天以内）的查看
3.针对设备报警的实时提示
4.接着就是一些统计信息，比如每月新增客户，新增设备的统计；所有设备的在线离线统计；有效设备和无效设备的统计等

亮点:(因为这是我做的第一个项目,和正式的，商用的肯定有很大的差距，就说一些自己感觉比较实用的点)
1.刚开始写的时候，我使用bootstrap作为样式库，而且很少去写css样式。写到后面发现有很大的局限，比如它里面有些样式和这个项目不符，同时我只会使用到这个样式表中很小一部分，大部分都不会用。后来干脆就不用了，就自己写一些全局样式，同时分好类，比如将按钮相关的样式单独放在一个css文件，表单相关的，表格相关的，布局相关的等等。这样可以很方便的去修改和复用，比如我现在正在做的医用监护仪管理系统，就是直接拿的这套样式，只需要改改里面很小部分，比如颜色，边框等。

2.封装了一些通用的组件，比如弹窗，按钮，分页器，表格等，后面在其他项目复用的时候，直接拿来用，只需要做一些很少的修改就行了。我后面正在做的也是基于这些组件，同时根据新的需求就可以继续增加，这样组件也会变得越来越丰富(我相信在公司团队里面都有属于团队自己的组件库供大家使用和维护)。

3.请求拦截器和响应拦截器的使用
刚开始把所有的HTTP请求逻辑都是放到组件内部的，后来随着接口数目的增多，代码越来越冗余，很多处理逻辑都是重复的，比如删除某一个数据成功或失败后弹出提示框，修改数据成功后弹出提示框。再加上每个数据接口都做了token认证，每次请求都要重复的添加到请求头部。后来就直接把这部分抽离出来，比如请求拦截器中，在所有的请求发送之前统一进行token头部的添加，根据收到响应的类型之后统一做出弹窗的处理，只把数据的处理逻辑放到组件中。大大减小代码冗余和降低出错的几率。

难点：
1.对于前端开发，页面的布局和样式搭配很难，如果没有专门的设计人员。因为目前我们组就我一个人做前端这一块，浪费了很多时间去找合适的样式搭配。
2.和后台数据接口的协调，后台数据传输格式一改变，我这边就要做相应的改变，有点被动。这也是自己开发经验少的了缘故

不足：
1.没怎么考虑浏览器的兼容性(我自己调试都是chrome)
```

### 2 远洋船舶发动机后台管理系统

```
两点：
1.登录权限分配 菜单列表存放在sessionStorage中 登录成功后根据菜单列表显示相应的条目



系统中填的:
该项目是面向重庆红江机械公司和其客户为目的进行开发的，远洋船舶发动机由于其地域分布广且分散，主要面临以下几个难点：一是发动机的反馈信息难以实时的收集到公司中，二是针对长时间使用的发动机其性能的实时追踪很重要。故设计一套基于发动机的转速，水温，滑油压力等多参数的监测平台，同时集合机器的故障信息反馈，权限管理等功能的综合管理平台。目的是为了让公司进行发动机的质量追踪和发动机使用过程中问题的收集，我主要负责项目管理系统的界面设计和功能实现，使用的技术栈为vue，vue-router，axios。目前完成的主要功能有：
1.登陆权限控制
2.远洋船舶的位置定位
3.远程监控数据展示（过去24小时的发动机的转速，水温，滑油压力，数据每15min更新一次）
4.发动机故障信息的上传
5.客户信息的增删改查




项目简介：
该项目是面向重庆红江机械公司和其客户为目的进行开发的，远洋船舶发动机由于其地域分布广且分散，主要面临以下几个难点：一是发动机的反馈信息难以实时的收集到公司中，二是针对长时间使用的发动机其性能的实时追踪很重要。故设计一套基于发动机的转速，水温，滑油压力等多参数的监测平台，同时集合机器的故障信息反馈，权限管理等功能的综合管理平台。目的是为了让公司进行发动机的质量追踪和发动机使用过程中问题的收集
目前已经完成的功能包括:实时监控，单点监控，发动机管理，维修中心，角色管理等。通过不同的账号的权限等级可以完成不同的功能，目前我们分了两种权限：一是管理员权限(可以完成所有的功能，由红江机械公司持有)，二是用户权限(只能进行实时监控，单点监控和维修中心)。

项目职责：
负责项目后台管理系统界面设计和开发，该项目是利用 Vuejs设计的 SPA 应用， 利用 sessionStorage 进行账号登陆的权限管理，同时结合 vue-router 进行前端路由的控制和导航的守卫，使用 axios 进行前后端统一的数据通信和拦截。在该项目中也基于 Vuejs 封装了一些自定义组件，比如弹窗、表单、按钮等。目前已完成的主要功有： 登陆权限控制、 船舶发动机的参数配置、客户信息的增删改查、发动机信息的增删改查和远程监控数据信息的展示。

怎么实现不同权限的：
首先，项目中所有的账号和相应的权限都是由管理员账号分配，只有被管理员分配的账号才是合法的，可以进行登录的账号。
当用户拿到这个账号，进入登录界面进行登录，浏览器发起一个post请求，当然这是一个加密的https请求，当后台拿到这个请求并验证合法过后，会返回一个json对象,其中包括：
1.账号的角色名称
2.账号的所依付的客户公司名称
3.一个唯一的token字符串
4.该账号所能使用的功能列表(我会根据这个列表显示不同的菜单栏目)
(以上的所有信息都是存放在vuex中的,作为一个全局的状态使用)


缺点:
前台无法保存登录状态，只要关闭窗口就要进行重新登录。后续考虑使用localStorage(自己封装可以设置过期时间的),下次再次进入这个系统就先去localStorage中取数据，数据存在就不用登录了。
```

# 笔试遇到的问题总结

## 1.promise的执行顺序[拼多多]

```js
let p = new Promise((res,rej) => {
  console.log('1')
  res('2')//这里并不会终止 除非加了return
  console.log('3')
})

p.then((r) => {
  console.log(r)
})

console.log('5')

//打印结果
1 3 5 2
```

## 2.铺地板[网易互联网]

```
用若干2*1和2*3的砖头(砖头可以旋转)去铺满一个2*n的地板，一共有多少中方案

#使用动态规划
```

```js
function solve(n){
  let dp = []
  let ans;
  dp[1] = 1
  dp[2] = 2
  dp[3] = 4
  if(n <= 3){
    return dp[n]
  }
  for(let i=4;i<=n;i++){
    ans = dp[1] % 10007 + dp[2] % 10007 + dp[3] % 10007 //动态规划递推式
    dp.shift()
    dp.push(ans)
  }
  console.log(ans)
}
```

### 3.for循环 定时器[B站]

```js
for(let i=0;i<3;i++){
    setTimeout(function(){
        console.log(i)
    },1000)
}

//打印 0 1 2 不是3 3 3 因为这样会生成3个定时器

for(var i=0;i<3;i++){
    setTimeout(function(){
        console.log(i)
    },1000)
}
//这样才是3 3 3
```

### 4 script脚本执行顺序

```
defer脚本会在文档渲染完毕后，DOMContentLoaded事件调用前执行(不是在DOMContentLoaded事件后)
```



# 一、美团

## 1.1 编程题

### 1.1.1 数组flatten

```js
function solver(arr){
    let res = []
    if(arr.every(ele => !Array.isArray(ele))){
        console.log(arr)
        return
    }
    for(let v of arr){
        if(Array.isArray(v)){
            res.push(...v)
        } else {
            res.push(v)
        }
    }
    solver(res)
}
solver([1,[234,345],2,[2,3,[34]]])


const flatten = function(arr){
  let res = []
  if(arr.every(val => !Array.isArray(val))){
    console.log(arr)
    return arr
  }
  for(let v of arr){
    Array.isArray(v) ? res.push(...v) : res.push(v)
  }
  return flatten(res)
}
console.log(flatten(arr))


function flatten(arr){
  for(let i=0;i<arr.length;){
    if(Array.isArray(arr[i])){
      arr.splice(i,1,...arr[i])
    } else {
      i++
    }
  }
  return arr
}
```

### 1.1.2 对象的排序

```js
function solver(obj){
    let arr = Object.entries(obj)
    arr.sort((a,b) => a[1] - b[1])
    let res = arr.map(ele => ele[0])
    console.log(res)
}

let exp01 = {
    'xu':23,
    'ta':45,
    'ni':24,
}
solver(exp01)
```

## 1.2 普通问题

### 1.2.1 promise的执行顺序

```js
let p = new Promise((res,jet) => {
  res(1)
})

setTimeout(()=>{
  console.log(2)
})

p.then(res => {
  console.log(res)
})
p.then(res => {
  console.log(res)
})

//输出：1 1 2

let p = new Promise((res,jet) => {
  res(1)
})

console.log(2)

p.then(res => {
  console.log(res)
})
p.then(res => {
  console.log(res)
})

//输出：2 1 1
```

### 1.2.2 打印的name是什么

```js
let name = 'global'
var obj = {
  name:'obj',
  test:function(){
    let name = 'func'
    console.log(this.name)
  }
}
let test = obj.test
test() //'global'
obj.test() //'obj'
```

### 1.2.3 let和const的区别（补充var）

* const一旦声明必须赋值，且不能占用null  <--> let可以只声明不赋值
* const声明后不能修改，如果是引用类型可以修改其属性 <--> let声明的都可以进行修改

* 全局什么的var会挂载到window对象上 <--> const和let不会
* var存在变量提升 <--> const和let不会
* var是函数作用域 <--> const和let是块级作用域
* 同一作用域下，var可以申明重名变量名 <--> const和let不行,即使之前使用var声明，后面再用let声明也会报错

### 1.2.4 v-if和v-show的区别和使用场景

原理：

* v-if控制元素的显示和隐藏是把整个dom元素渲染或者删除
* v-if在每次切换的时候都会重新创建或者销毁元素，有较高的切换性能消耗
* v-if加载是惰性的，如果初始渲染条件为假，什么都不做。直到第一次条件变为真才进行渲染
* v-show不管初始条件是什么，都会渲染。是通过css的display属性来控制元素的显示和隐藏

使用场景：

* 如果元素要进行比较频繁的切换，推荐使用v-show，反之用v-if

### 1.2.5 vue的watch中deep和immediate的区别

* immediate 组件一实例化，就立马执行handler中的函数
* deep 深度监听一个对象，如果这个对象的属性值发生了变化，就会触发handler中的函数

```js
var vm = new Vue({
        el: '#box',
        data: {
            lists: [
                {
                    id: 1,
                    title: 'lorem',
                    profile: {id: 1, username: 'lorem'}
                },
                {
                    id: 2,
                    title: 'andy',
                    profile: {id: 2, username: 'andy'}
                }
            ]
        },
        watch: {
            //  改成了一个对象，属性值 handler 固定写法
            lists: {
                handler: function (newVal, oldVal) {
                    console.log('lists change....')
                },
                deep: true,
                // 代表开启深度监控。意思是数据的任何一个属性发生变化，监视函数需要执行
                immediate: true,
                // 如果immediate 设置为true, 代表代码一加载 立马执行监视函数 初始值oldval为undefined
            }
        }
    })

```

### 1.2.6 组件之间的传值

父给子传值：

* 子组件通过props属性接受值
* 父组件通过引用子组件并通过子组件的属性传值

子给父传值：

* 子组件通过`$emit`方法传递参数
* 父组件监听这个事件，接收值

兄弟之间传值：

* 需要经过它们公共的祖先，一个子传父，一个父传子

### 1.2.7 前端路由怎么进行切换

首先需要明确的是，URL跳转有两步

* step1 浏览器地址栏输入要跳转的地址（输入可以手动，也可以js改变，也可以通过a标签）
* step2 触发一个浏览器的事件发送HTTP请求（手动输入按enter键触发，js通过history的接口触发，a标签通过点击触发）
* 前端路由的关键是改变步骤二

前端路由的实现有两种方式：

1.利用H5新增的history接口

* 关键步骤，web服务器设置将所有的请求都返回同一个响应（单页面的响应地址）

* 如果点击浏览器的前进和后退，或者调用history的back(),forward()和go()和a标签会触发window的popstate事件

* pushState(state,title,link)接口，虽然浏览器地址发生了变化，但是不会向web服务器发送请求
* 通过pushstate中的state对象来传递两个不同路由之间的数据
* 通过在popstate事件中利用js改变页面中内容即可，实现“路由跳转效果”

2.利用url中的hash

* 如果浏览器URL的hash部分发生了变化，会触发window上的hashchang事件

* 触发方式

  * 直接手动在URL中更改hash值
  * 通过JS修改location.hash的值（带#号）
  * 浏览器的前进和后退按钮(导致锚部分发生变化)
  * 点击带锚点的链接

  ```jsx
  <a href="#/he">点我</a>
  <p>hash:<span id="hash"></span></p>
  <script>
      let hash = document.getElementById('hash')
      window.onhashchange = function(e){
          //该事件对象中包含两个重要的属性 可以利用这个实现两个路由之间数据的传递
          //1.oldURL oldURL: "file:///F:/VSCodeWorkspace/XuCode/HTML/testURL.html#/he"
          //2.newURL newURL: "file:///F:/VSCodeWorkspace/XuCode/HTML/testURL.html#"
          console.log(e)
          let hashVal = location.hash
          console.log(hashVal)
          hash.textContent = hashVal
      }
  </script>
  ```

* 于是只要在hashchange事件中利用js改变页面中内容即可，实现“路由跳转效果”，hash改变不会向web服务器发起HTTP请求

### 1.2.8 盒模型的区别

* 盒模型有两种， IE 怪异盒子模型、W3C标准盒子模型；

* 盒模型是由： 内容(content)、内边距(padding)、边框(border)、外边距(margin) 组成的。

* 标准模型的宽高是指的content区宽高； IE盒模型的宽高是指的content+padding+border的宽高。

w3c标准盒模型： css宽度属性就是内容区域的宽度

* CSS的width和height属性是内容区域即content的width和height
* 一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)

IE盒子模型：css宽度属性就是内容区域的宽度 + padding + border

* CSS的width和height属性除了content区域外，还包含padding和border。
* 一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值）

# 二、vivo

## 2.1 普通问题

### 2.1.1 清除浮动的方式，怎么解决高度塌陷，有几种方式

* 浮动会影响父元素的高度，同时会影响浮动元素后面元素的排列

* 清除浮动的影响共有四种方式

  ```
  1.给父元素指定高度（但是前提是浮动元素的高度已经知道）
  2.在浮动元素的后面加一个空的div标签，并且设置clear:both
  3.给浮动元素的父级div的伪类::after(IE8以下不支持)
    div::after {
    	content:'',
    	display:block,
    	clear:both,
    }
  4.给父级元素设置overflow:hidden(但是必须同时设定父元素的宽度，不能设定高度)
  ```

### 2.1.2 BFC

* BFC是指一个独立的渲染容器，只有块级盒子才能形成，它规定了内部的块级盒子是如何布局的，这个区域内部的元素不会影响到外部的元素
* 如何形成
  * 根元素，即HTML元素
  * 定位元素，position: fixed/absolute
  * 浮动元素，float 不为none
  * overflow不为visible
  * display的值为inline-block、table-cell、table-caption

* 作用
  * 防止margin发生重叠
  * 防止元素高度塌陷
  * 形成bfc的元素不会被浮动元素所重叠++（可以使用这个形成两栏布局，其中一栏自适应，虽然弹性盒也能实现）

### 2.1.3 事件委托（如何判断是哪个元素触发的，常见ul，li结构）

* 添加监听器到父元素上，来避免监听每个子元素

* 通过e.target可以知道是那一个元素触发的，但是没有办法知道是第几个元素触发的，要解决这个问题，可以

  * 给每个元素添加data-xxx属性，显示指定索引

  * ```js
    //第二种方法
    //先通过js获取ul元素，再利用js获取该ul中的li
    var oUl = document.getElementById("ul");
    var aLi = oUl.getElementsByTagName("li");
    oUl.onclick = function(e){
        let target = e.target
        if(target.nodeName.toLowerCase() === 'li'){
            let index;
            for(let i=0;i<aLi.length;i++){
                if(aLi[i] === target){
                    index = i
                }
            }
            console.log('我的下标是第'+index+'个')
        }
    }
    ```



### 2.1.4 弹性盒布局遇到的问题

* 浏览器的兼容性差，只能兼容到IE9及以上
* 但是在兼容性处理上，我确实做得不够仔细，

### 2.1.5 闭包的作用

```
1.可以避免将变量暴露到全局，如果暴露，那么可以直接在浏览器的控制台中使用，存在隐患
```





## 2.2 hr面

### 2.2.1 相比于计算机专业同学的优劣势

```
首先在基础理论上，由于自己没有
```



### 2.2.2 未来打算

```
自己选择了前端领域，就要做一行爱一行。
```



### 2.2.3 看你专业也不是这个，那为什么选择做前端呢？

```
接触到前端是自己上了研究生才开始的，一方面是自己的项目所要求，通过学习，自己也顺利地完成了一些项目（就是前面所提到的）。另一方面就是自己在学习前端的过程中，培养了对前端的兴趣。我对写前端的感觉就像是自己在完成一个艺术品一样，当自己的项目做完并且上线过后，那种感觉应该就像一个画家完成了自己辛苦做的画一样。兴趣始终都是最好的老师，因为前端领域涉及的东西很广，同时技术更新很快，拥有浓厚的兴趣才能始终让自己一直保持学习下去的动力。
但是你要说兴趣只有这一个吗？那肯定不是，我平时也看机器学习和网络爬虫，但是那个掌握得不够，相比于前端来说的话
```



### 2.2.4 你在前端的优势？



### 2.2.5 在项目中遇到了哪些问题

* 一个是界面的设计问题（比如布局，颜色搭配等）
* 和后端进行接口调试过程中遇到的问题（比如传输的数据格式没有提前约定好，接口突然不用了，有突然加入新的接口，虽然做不到完全避免，但是要尽量避免出现这些情况）

# 三、招银网络科技

## 3.1 一面

### 3.1 js基本数据类型7种(注意undefined,null) 这不是内置的对象

* undefined
* null
* number
* string
* boolean
* object 对象
* symbol 符号

```js
// typeof 只会返回六种 number string boolean undefined object function
```



### 3.2 代码会报错吗

```js
hello()
function hello(){ //这是函数声明 函数声明整个函数都会进行提升(同时如果存在同名的变量，会进行覆盖) 所以不会报错 
    alert('hello')
}

//下面这种情况就会出错
hello()
var hello = function(){ //这是函数表达式 函数表达式变量会进行提升 虽然也会报错 但是报错为TypeError:hello is not a function
    alert('hello')
}

//等价于
var hello;
hello()
hello = function(){
    alert('hello')
}
```

### 3.3 a标签的target属性

```html 
<a href="" rel='' target=''></a>
```

* href规定链接的目标 URL
* 规定当前文档与目标 URL 之间的关系。仅在 href 属性存在时使用。
* target
  * _blank 浏览器总在一个新打开、未命名的窗口中载入目标文档
  * _self 点击会覆盖当前窗口
  * _parent 点击会覆盖当前窗口
  * _top 点击会覆盖当前窗口
  * 指定一个框架frame的name属性 那么会在这个框架中显示文档

### 3.4 H5新增了哪些新特性

* 语义化标签 header nav section aside footer
* 新增的input类型 color date url email range等
* 新的图形标签 svg
* 新的多媒体标签 video auido
* 新的HTML5API 地理位置(Geolocation) 拖放 本地存储

废弃

* frame 定义子窗口
* frameset 定义框架集

### 3.5 vue的拦截器用过吗？怎么用的？

* 登录接口没有做拦截器，

* 请求拦截器，两个功能

  ```
  1.在发起请求前，将sessionStorage中的token加入到请求头中，具体为token:'xsdsdsdddsdsdwedsd'
  2.判断请求是否为delete,是的话要进行删除确认的弹框提示
  ```

* 响应拦截器

  ```
  对后台返回的数据做响应的格式处理，比如：
  1.是删除，做出删除成功提示
  2.是修改，做出修改成功提示
  3.是提交数据，做出提交成功提示
  4.如果请求数据时候，登录已经过时(后台返回401)，跳转到登录界面
  ```

  

### 3.6 手写简单的MVVM模型

```jsx
  <input type="text">
  <span id="data"></span>
  <script>
    let input = document.getElementsByTagName('input')[0]
    let span = document.getElementById('data')
      
    let data = {}//响应式的数据对象
   
    input.addEventListener('input',function(e){
      let val = e.target.value
      data['a'] = val//当input发生改变的时候，同时改变data的值 
      span.innerText = val
    })
      
    Object.defineProperty(data,'a',{
      get(){
        return a
      },
      set(val){//当data发生改变的时候，同时改变视图input的值 
        a = val
        input.value = val
      }
    })
  </script>
```

### 3.7 token是怎么使用的

* 1.用来验证每一个数据请求接口是否合法，具体就是把其添加到每一个请求的请求头中

* 2.导航守卫（合法性验证是后台进行的）

```js
     {
       path:'',
       component :() => import('@/components/ContentLayout/HomePageLayout.vue'),
       meta:{
        title:'首页',
        auth:true //1.给每一个导航需要进行登录通过后才能进行访问的，添加导航守卫
      }
     },
     {
       path:'/info',
       component:() => import('@/components/ContentLayout/InfoPageLayout.vue'),
       meta:{
        title:'信息',
        auth:true
      }
     }

router.beforeEach((to,from,next) => {
  if(to.meta.title){//改变网页的标题
    document.title = to.meta.title
  }
  if(to.meta.auth){//是否需要验证才能访问
    if(sessionStorage['token']){//如果存在token ？？ 
      next()
    } else {
      next('/login')
    }
  } else {
    next()
  }
})
```

### 3.8 js为什么要使用严格模式

* 消除代码运行的一些不安全之处，保证代码运行的安全
* 提高编译器效率，增加运行速度
* 为未来新版本的JavaScript做好铺垫

主要包括：

```
1.不允许使用未声明的变量(否则会挂载到全局)
2.不允许使用delete删除变量或对象。
3.不允许变量重名。
4.不允许使用八进制
5.不允许使用转义字符
6.禁止this关键字指向全局对象
7.严格模式新增了一些保留关键字(保证将来的js版本的过渡)
```

### 3.9 项目中自己封装哪些组件

* 盒子box 容器
* 按钮
* 徽章
* 弹框
* 分页器
* 表格
* 列表项

## 3.2 二面

### 1.级联组件怎么实现

### 2.响应式怎么实现

### 3.登录怎么保证安全

* 第一种情况：这里说的登录安全，是说登录的时候，发送给后台的账号和密码不会在中途被窃取

```
0.密码进行加密后传输
1.使用https传输(对加密后密码再一次加密)
2.强制用户使用有一定强度且复杂的密码，必须要有大小写加数字
3.密码不要明文保存到数据库(使用MD5这一类的散列加密算法)
4.前端禁止用户输入导致sql注入的字符，后台也要做sql注入的防护
```

* 第二种情况：账号和密码直接被第三人拿到了

```
1.登录的时候进行手机验证码操作
2.登录的时候加入指纹验证
```



### 4.一个接口返回几千条数据，怎么优化

# 四、字节跳动

## 4.1 一面

### 4.1.1 输出是什么？

```js
const show = () => {
    console.log(this) //箭头函数没有自己的this，这里直接绑定到完成作用域
}

let obj = {
    show:show
}

show() //window 
obj.show() //window
```

### 4.1.2 输出是什么？

```js
function f(){
    console.log(i) //这里打印undefined
    for(var i=0;i<2;i++){ //var是函数作用域，直接提升到函数的最上面，
        console.log(i)
    }
}
f() //undefined 0 1
```

### 4.1.3 输出是什么?

```js
function foo(){
    console.log('foo')
    Promise.resolve().then(() => {
        console.log('micro-foo')
    })
    setTimeout(() => {
        console.log('macro-foo') 
    },0)
}

function bar(){
    console.log('bar')
    Promise.resolve().then(() => {
        console.log('micro-bar')
    })
    setTimeout(() => {
        console.log('macro-bar') 
    },0)
    foo()
}

bar()
console.log('global')
Promise.resolve().then(() => {
    console.log('micro-global')
})
setTimeout(() => {
    console.log('macro-global')
},0)

//bar foo global micro-bar micro-foo micro-global macro-bar macro-foo macro-global
```

### 4.1.4 cookie在遇到跨域的时候浏览器会自动携带吗？

```
默认不会
只有在不跨域的情况下才会自动带上
```

### 4.1.5 css外边距合并的问题

* 在默认文档流中才会存在，且只有块级元素之间才会合并
* 出现这个的原因：css最初是为了方便文字排版，设置合并是为了照顾段落的间距设置的

```html
a.上下元素挨着一起
.div1{
    margin:10px; 
    border:1px solid gray;
}
.div2{
    margin:20px; 
    border:1px solid gray;
}
<div class='div1'>内容1</div>
<div class='div2'>内容2</div>
结果 div1和div2的间距是20px
解决方式:
1.设置第一个元素的定位为position:absolute 或 float:left 或 display:inline-block(但是这样会改变布局)
2.设置overflow:hidden不行

b.子元素包含在父元素之中
.div1{
	margin:10px; 
}
.div2{
	margin:30px; 
    border:1px solid gray;
}
<div class='div1'>
    <div class='div2'>内容1</div>
</div>
结果 div2的上边和div1的上面挨着，且div1的上边距直接变为30px，不是10px
解决方式:
1.父元素设置overflow:hidden
2.父元素加一个边框，设置padding


c.空元素的外边距合并(上下元素合并的一种情况)
.div1{
    margin:10px; 
}
.div2{
    margin:10px; 
    border:1px solid gray;
}

<div class='div1'>内容1</div>
<div class='div2'></div>
<div class='div1'>内容1</div>
结果 元素div2的上下边距分别于上下元素合并，边框变成了一条直线
解决方式: 同a
```

### 4.1.6 HTTPS的建立过程 (3个部分)

<img src="../../AppData/Roaming/Typora/typora-user-images/image-20200723110522392.png" alt="image-20200723110522392" style="zoom:80%;" />

```
第一部分：协商
1.浏览器向服务器发送自己支持的加密协议,支持的SSL版本号
2.服务器从中筛选出一个合适的加密协议(双方都支持的加密算法,比如AES算法)，同时向浏览器返回自己的证书

第二部分：传输对称密钥
3.浏览器验证证书(证书中有公钥)的是否合法(不合法会进行弹窗提示)
4.浏览器生成对称密钥(本质就是一个随机的字符串,这个字符串将被用于AES算法加密)，并通过公钥对这个字符串加密发给服务器
5.服务器器使用私钥解密拿到这个对称密钥

第三部分：传输内容
6.双方可以使用这个对称密钥对内容进行加密后传输
```

```
非对称加密算法：
1.RSA算法
该算法基于数论事实:将两个大的素数相乘十分容易，但是对其乘积进行因式分解极其困难，因此可以将乘积作为公钥
2.ECC算法

对称加密：
1.AES算法(对称密钥的长度更长，128 192 256位)
2.DES算法(对称密钥的长度为56位二进制，暴力破解需要2^56次，不安全)

散列算法(不需要密钥就可以进行加密)(常用于检查文件是否被篡改)：
1.MD5算法
2.SHA256算法
```





### 4.1.7 vue中的key是用来干嘛的（补充diff算法）

```
主要运用在vnode的diff算法中，确切来说实在更新节点的时候，如果两个vnode的key值一样，不会触发节点的更新，即使两个节点中在前后的内容不一样。
同理如果在使用v-for的时候不使用key,那么在进行diff更新节点的时候，就不得不去检查节点的内容，会降低渲染的速度
```

## 4.2 二面

### 4.2.1 babel.config.js是干嘛的

```js
对哪些Es6的语法进行转义相关配置
```

### 4.2.2 meta标签怎么和响应式搭配

```
设置这个meta标签支持不同设备的页面
```

### 4.2.3 哪些行为会受到浏览器的跨域限制

```
1.ajax
2.cookie
```

```
cookie的samesite字段,用于控制cookie发送行为
```

![image-20200727154228536](../../AppData/Roaming/Typora/typora-user-images/image-20200727154228536.png)

### 4.2.4 for in 和for of区别

```
1.for in[可以遍历对象和数组]
遍历数组的时候不能按照元素出现顺序
该方法会遍历数组或者对象上的原型链上的可以枚举的属性(在原型上的系统自带的都是不可枚举,自己添加的属性默认是枚举的)
不推荐遍历数组

2.for of[不可以遍历对象]
可以正确的遍历数组，且响应break continue return
```

```js
let obj1 = {a:1,d:4}
obj1.__proto__['x'] = 'x' //自己在原型上添加的属性，默认是可以枚举的

for(const key in obj1){
  if(obj1.hasOwnProperty(key)){//如果没有这一句 打印 a d x
    console.log(key) //打印 a d
  }  
}
```

### 4.2.5 package.json中dependencies和devDependencies的区别

```
1.devDependencies(开发依赖,只有在使用开发服务器的时候会用到,比如babel相关 webpack相关)
(1)内容：是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围
(2)作用：该模块中所列举的插件属于开发环境的依赖（比如：测试或者文档框架等）
(3)部署来源：通过你npm install进行依赖安装时加上-save-dev，devDependencies对象中便会增加echarts安装配置

2.dependencies(生产环境的依赖)
(1)内容：是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围
(2)作用：该模块中所列举的插件属于生产环境的依赖（程序正常运行需要加载的依赖）
(3)部署来源：通过你npm install进行依赖安装时加上-save，dependencies对象中便会增加echarts安装配置。

3.区别
开发环境的依赖在打包的时候(npm run build)不会被打包到输出文件中
```

### 4.2.6 解析模板字符串

```js
let templateStr = 'xxx${obj2.d},sdx${obj2.b.c}'
let obj2 = {a:1,b:{c:34},d:4}

function parseStr(str){
  let reg = /(?<=\${)([\w|\.]+)(?=})/g //匹配要进行js运算的部分
  let deReg = /[(\${)|}]/g //匹配${ 和 }
  let ans = str.replace(reg,function($,$1){ //使用eval()进行运算
    return eval($1)
  })
  ans = ans.replace(deReg,'')//替换掉标志 ${ 和 }
  console.log(ans)
}
parseStr(templateStr) //xxx4,sdx34
```

### 4.2.7 实现系统的序列化函数

```
JSON标准格式
1.首先明确整体是一个字符串
2.转义前是字符串的,转义后必须有双引号显示出来(其余的数据一律转为string类型,这个不需要加双引号)
3.js默认忽略undefined 函数
```

```js
function myStringify(obj){
  const isType = Object.prototype.toString
  let ans = '';

  if(isType.call(obj) === '[object Array]'){ //数组
    ans = ans + '['
    for(let v of obj){
      ans = ans + myStringify(v) + ','
    }
    ans = ans.slice(0,-1) + ']' //去掉末尾的逗号
  } else if(isType.call(obj) === '[object Number]'){//数字
    ans = ans + obj
  } else if(isType.call(obj) === '[object String]'){//字符串
    ans = ans + '\"' + obj + '\"'
  } else if(isType.call(obj) === '[object Object]'){//对象字面量
    ans = '{'
    for(const key in obj){
      ans = ans + '\"' + key + '\"' + ':' + myStringify(obj[key]) + ','
    }
    ans = ans.slice(0,-1) + '}' //去掉末尾的逗号
  } else if(isType.call(obj) === '[object Boolean]'){//布尔值
    ans = ans + obj
  } else if(isType.call(obj) === '[object Null]'){ //null
    ans = ans + obj
  } else { //其他类似函数,undefined js默认会忽略,这里为了简单全部返回系统的toString
    ans = ans + myStringify(isType.call(obj))
  }
  return ans
}

let obj2 = {a:1,b:{c:34},d:4,e:[1,2,'sx'],x:/\w/,f:()=>{},n:NaN}
console.log(myStringify(obj2))
//输出 {"a":1,"b":{"c":34},"d":4,"e":[1,2,"sx"],"x":"[object RegExp]","f":"[object Function]","n":NaN}
```

### 4.2.8 写一个类似于axios的封装

```js
let axios = {}
//模拟一个get请求
axios.get = function(url,data){
  let xhr = new XMLHttpRequest()
  return new Promise((res,rej) => {
    xhr.open('GET',url)
    xhr.send(data || {})
    xhr.onreadystatechange = function(){
      if(xhr.readyState === 4){
        if(xhr.status === 200){
            res(xhr.responseText)
        } else {
            rej(xhr.status)
        }
      }
    }
  })
}
```

## 4.3 三面

### 4.3.1 怎么实现扫码登录(手机点击登录后，电脑端是怎么知道的)

![image-20200731150204545](../../AppData/Roaming/Typora/typora-user-images/image-20200731150204545.png)

### 4.3.2 cookie中的secure是干嘛的,怎么写入cookie

```
secure是一个布尔值，true表示这条cookie只能在HTTPS中使用

写入有两种：
1.通过http响应头的字段set-cookie
2.通过js的document.cookie
```

### 4.3.3 设计一个随输随搜的组件

```
1.首先考虑组件需要使用那些外部的数据(比如本次组件需要:请求的接口API)
2.组件需要那些内部数据(比如本次组件需要:来自用户的输入inputText,收到的查询结果resultList)
3.需要使用哪些事件(比如本次组件需要:需要监听输入框的input事件)
4.需要向外暴露哪些事件
```

### 4.3.4 tcp为什么要进行4次挥手

![image-20200731152126338](../../AppData/Roaming/Typora/typora-user-images/image-20200731152126338.png)

```
在进行4次挥手的时候，
当客户端收到服务器的FIN信号的时候，客户端会发送一个ACK信号，然后会等待2MSL
(因为可能服务器没有收到ACK信号，服务器没有收到ACK信号的时候会再一次发送FIN信号,等待2MSL就是为了收到下一个FIN信号)

如果只进行三次挥手
那么客户端最后发送的ack报文如果丢失，服务器就会因为迟迟收不到ack报文就会重发fin报文,就无法进入close状态
```



### 4.3.5 项目中的登录功能怎么设计的（怎么让电脑一段时间内自动登录）

```
使用cookie
```

# 五、顺丰

# 六、京东

## 6.1 一面

### 6.1.1 大文件怎么分块上传？

```
大文件上传需要实现下面几个需求
1.支持拆分上传请求(切片)
2.支持断点续传
3.支持显示上传进度和暂停上传
```

```js
//对文件进行切片 返回一个分块数组
function slice(file, piece = 1024 * 1024 * 5) {
  let totalSize = file.size; // 文件总大小
  let start = 0; // 每次上传的开始字节
  let end = start + piece; // 每次上传的结尾字节
  let chunks = []
  while (start < totalSize) {
    // 根据长度截取每次需要上传的数据
    // File对象继承自Blob对象，因此包含slice方法
    let blob = file.slice(start, end); 
    chunks.push(blob)

    start = end;
    end = start + piece;
  }
  return chunks
}

//分块上传
let file =  document.querySelector("[name=file]").files[0]; //拿到文件

const LENGTH = 1024 * 1024 * 0.1;
let chunks = slice(file, LENGTH); // 首先拆分切片数组

chunks.forEach((chunk,index)=>{
  let fd = new FormData();
  fd.append("file", chunk);
  fd.append("chunk", index + 1); //对上传的文件进行顺序编号
  post('/mkblk.php', fd)
})
```



### 6.1.2 z-index

```
1.z-index只能在position属性值为relative或absolute或fixed的元素上有效

2.在浮动元素上不起作用
```

### 6.1.3 阻止冒泡

```js
e.stopPropagation() //w3c
e.cancelBubble = true //IE
```

# 七、作业帮

### 1.js代码题

```js
window.color = 'red'
function fn(){
    this.color = 'fn'
    return {
        sayColor:() => {
            console.log(this.color)//箭头函数的this指向包裹该函数的外层函数作用域的this,因为外层有函数,直接和外层的this相等，外层的this改变，它也会改变
        }
    }
}
let obj = {
    color:'obj',
    sayColor:() => {
        console.log(this.color)//箭头函数的this指向包裹该函数的外层函数作用域的this,因为外层就是全局，故指向window
    }
}
let sayColor = () => {
    console.log(this.color) //箭头函数的this指向包裹该函数的外层函数作用域的this,因为外层就是全局，故指向window
}

sayColor()
new fn().sayColor()
fn().sayColor()
sayColor()
obj.sayColor()

//打印 red fn fn fn fn
```

### 2.箭头函数可以调用call apply bind吗

```
可以调用，不会报错，但是不会有效果
```

### 3.原地翻转字符串

```
这能实现吗？？？
```

### 4.简单总结闭包++

```
闭包是指有权访问另一个函数作用域内变量的函数。 -- 《JavaScript高级程序设计》

闭包是通过改变JS回收机制保留某段作用域的一种手段。
当一个函数执行完毕后，里面的局部变量是会被JS自带的垃圾回收机制给销毁的，从而释放内存。但是如果返回一个函数，而且函数里面有用到父级函数声明的变量，那么此时，变量不会被回收，因为还有可能被用到，并且外界可以通过函数访问这段作用域下的变量。

形成闭包后，对应作用域中的变量永远不会被回收

优点：
变量长期驻扎在内存中。
避免全局变量的污染。
私有成员的存在。

缺点：
因为不会被GC回收，所以常驻内存，会增大内存的使用量，使用不当会造成内存泄露。


一个典型的例子：循环中打印定时的数字
```



# 八、拼多多

### 1.promise的错误传递问题

```js
//1. 一旦promise的状态变为fulfilled或者rejected, 在其后面再抛出错误无效(在promise中，rej函数就等于抛出错误)
let p = new Promise((res,rej) => {
    resolve('ok');
    throw new Error('error')
})

p.then(val => console.log(val)).catch(err => console.log(err)) //打印ok

//2. 链式调用catch方法 错误会被最近的catch捕获
let p = new Promise((res,rej) => {
  rej('error')
})
p.then(val => console.log(val)).catch(err => console.log(err + '1')).catch(err => console.log(err + '2'))
//打印error1 

//3. catch方法和then方法默认返回一个新的promise对象(状态为pending),除非自己return一个值用来覆盖默认值
let p = new Promise((res,rej) => {
  res('success1')
})

let p1 = p.then(val => {
  console.log(val);
  return Promise.reject('error')
}).catch(e => console.log(e))
//依次打印 success1 error
```

### 2.一种更快的数组flatten方式 [使用数组的toString()方法]

```js
let nestArr = [1,2,3,[345,56,78,78,[23,45,[56]],[45,78]],3,[34,90]]
function flatten(arr){
  return arr.toString().split(',').map(num => parseInt(num))
}
console.log(flatten(nestArr)) //[ 1, 2, 3, 345, 56, 78, 78, 23, 45, 56, 45, 78, 3, 34, 90 ]
```

### 3.如何快速获取某一个元素中的HTML元素

```jsx
.A .B {
	color:red
}

//目标 找出所有位于A元素下面的B元素
//1. 使用querySelectorAll()
let B = document.querySelectorAll('.A .B')

//2. 使用常规方式
let A = document.getElementsByClassName('A') //先找出所有的A
let B = Array.from(A).map(elm => elm.getElementsByClassName('B')) //在从A中选出B

//原理
/*
* Document类上包含所有查找元素的方式
*
* 但是Element类上只有两种方式: getElementsByClassName() 和 getElementsByTagName()
*
*/
```

# 九、腾讯

### 1.进程和线程的区别

```
1. 进程有自己独立的地址空间，每启动一个进程，系统就会为它地址空间；而线程是共享进程中的数据。
2. 切换一个线程的花费远比进程小得多，同时创建一个线程的开销也小得多。
3. 线程之间的通信更方便，进程之间的通信需要用通信的方式。
```

### 2.数组和链表的区别

```
1. 数组是一块连续的内存空间，链表不是(但是链表中的每一个元素存放了下一个元素所在的地址)
2. 读取 数组为O(1) > 链表为O(n)
3. 插入 数组为O(n) < 链表为O(1)
4. 删除 数组为O(n) < 链表为O(1)

注意：只有操作链表的头部元素才是O(1)，但是不管怎么说，链表的插入和删除元素都比数组快
```

### 3.OSI七层模式和常用的网络层级

### 4.哪些层有数据的验证功能

### 5.进程之间的通信方式

```
1.套接字socket 可以在不同机器的进程之间通信
2.管道
```

