

# #补充

## #.1 手写ajax

```js
function ajax(url,method,data){
    const xhr = new XMLHttpRequest()
    xhr.onreadystatechange = function(){
        if(xhr.readystate === 4){
            if(xhr.status === 200){
                console.log(xhr.responseText)
            } else {
                console.log(xhr.statusText)
            }
        }
    }
    xhr.open(method,url,true)
    xhr.send(data || {})
}
```





# 一、美团

## 1.1 编程题

### 1.1.1 数组flatten

```js
function solver(arr){
    let res = []
    if(arr.every(ele => !Array.isArray(ele))){
        console.log(arr)
        return
    }
    for(let v of arr){
        if(Array.isArray(v)){
            res.push(...v)
        } else {
            res.push(v)
        }
    }
    solver(res)
}
solver([1,[234,345],2,[2,3,[34]]])
```

### 1.1.2 对象的排序

```js
function solver(obj){
    let arr = Object.entries(obj)
    arr.sort((a,b) => a[1] - b[1])
    let res = arr.map(ele => ele[0])
    console.log(res)
}

let exp01 = {
    'xu':23,
    'ta':45,
    'ni':24,
}
solver(exp01)
```

## 1.2 普通问题

### 1.2.1 promise的执行顺序

```js
let p = new Promise((res,jet) => {
  res(1)
})

setTimeout(()=>{
  console.log(2)
})

p.then(res => {
  console.log(res)
})
p.then(res => {
  console.log(res)
})

//输出：1 1 2

let p = new Promise((res,jet) => {
  res(1)
})

console.log(2)

p.then(res => {
  console.log(res)
})
p.then(res => {
  console.log(res)
})

//输出：2 1 1
```

### 1.2.2 打印的name是什么

```js
let name = 'global'
var obj = {
  name:'obj',
  test:function(){
    let name = 'func'
    console.log(this.name)
  }
}
let test = obj.test
test() //'global'
obj.test() //'obj'
```

### 1.2.3 let和const的区别（补充var）

* const一旦声明必须赋值，且不能占用null  <--> let可以只声明不赋值
* const声明后不能修改，如果是引用类型可以修改其属性 <--> let声明的都可以进行修改

* 全局什么的var会挂载到window对象上 <--> const和let不会
* var存在变量提升 <--> const和let不会
* var是函数作用域 <--> const和let是块级作用域
* 同一作用域下，var可以申明重名变量名 <--> const和let不行

### 1.2.4 v-if和v-show的区别和使用场景

原理：

* v-if控制元素的显示和隐藏是把整个dom元素渲染或者删除
* v-if在每次切换的时候都会重新创建或者销毁元素，有较高的切换性能消耗
* v-if加载是惰性的，如果初始渲染条件为假，什么都不做。直到第一次条件变为真才进行渲染
* v-show不管初始条件是什么，都会渲染。是通过css的display属性来控制元素的显示和隐藏

使用场景：

* 如果元素要进行比较频繁的切换，推荐使用v-show，反之用v-if

### 1.2.5 vue的watch中deep和immediate的区别

* immediate 组件一实例化，就立马执行handler中的函数
* deep 深度监听一个对象，如果这个对象的属性值发生了变化，就会触发handler中的函数

```js
var vm = new Vue({
        el: '#box',
        data: {
            lists: [
                {
                    id: 1,
                    title: 'lorem',
                    profile: {id: 1, username: 'lorem'}
                },
                {
                    id: 2,
                    title: 'andy',
                    profile: {id: 2, username: 'andy'}
                }
            ]
        },
        watch: {
            //  改成了一个对象，属性值 handler 固定写法
            lists: {
                handler: function (newVal, oldVal) {
                    console.log('lists change....')
                },
                deep: true,
                // 代表开启深度监控。意思是数据的任何一个属性发生变化，监视函数需要执行
                immediate: true,
                // 如果immediate 设置为true, 代表代码一加载 立马执行监视函数 初始值oldval为undefined
            }
        }
    })

```

### 1.2.6 组件之间的传值

父给子传值：

* 子组件通过props属性接受值
* 父组件通过引用子组件并通过子组件的属性传值

子给父传值：

* 子组件通过`$emit`方法传递参数
* 父组件监听这个事件，接收值

兄弟之间传值：

* 需要经过它们公共的祖先，一个子传父，一个父传子

### 1.2.7 前端路由怎么进行切换

首先需要明确的是，URL跳转有两步

* step1 浏览器地址栏输入要跳转的地址（输入可以手动，也可以js改变，也可以通过a标签）
* step2 触发一个浏览器的事件发送HTTP请求（手动输入按enter键触发，js通过history的接口触发，a标签默认触发）
* 前端路由的关键是改变步骤二

前端路由的实现有两种方式：

1.利用H5新增的history接口

* 关键步骤，web服务器设置将所有的请求都返回同一个响应（单页面的响应地址）

* 如果点击浏览器的前进和后退，或者调用history的back(),forward()和go()和a标签会触发window的popstate事件

* pushState(state,title,link)接口，虽然浏览器地址发生了变化，但是不会向web服务器发送请求
* 通过pushstate中的state对象来传递两个不同路由之间的数据
* 通过在popstate事件中利用js改变页面中内容即可，实现“路由跳转效果”

2.利用url中的hash

* 如果浏览器URL的hash部分发生了变化，会触发window上的hashchang事件

* 触发方式

  * 直接手动在URL中更改hash值
  * 通过JS修改location.hash的值（带#号）
  * 浏览器的前进和后退按钮(导致锚部分发生变化)
  * 点击带锚点的链接

  ```jsx
  <a href="#/he">点我</a>
  <p>hash:<span id="hash"></span></p>
  <script>
      let hash = document.getElementById('hash')
      window.onhashchange = function(e){
          //该事件对象中包含两个重要的属性 可以利用这个实现两个路由之间数据的传递
          //1.oldURL oldURL: "file:///F:/VSCodeWorkspace/XuCode/HTML/testURL.html#/he"
          //2.newURL newURL: "file:///F:/VSCodeWorkspace/XuCode/HTML/testURL.html#"
          console.log(e)
          let hashVal = location.hash
          console.log(hashVal)
          hash.textContent = hashVal
      }
  </script>
  ```

* 于是只要在hashchange事件中利用js改变页面中内容即可，实现“路由跳转效果”，hash改变不会向web服务器发起HTTP请求

### 1.2.8 盒模型的区别

* 盒模型有两种， IE 怪异盒子模型、W3C标准盒子模型；

* 盒模型是由： 内容(content)、内边距(padding)、边框(border)、外边距(margin) 组成的。

* 标准模型的宽高是指的content区宽高； IE盒模型的宽高是指的content+padding+border的宽高。

w3c标准盒模型： css宽度属性就是内容区域的宽度

* CSS的width和height属性是内容区域即content的width和height
* 一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)

IE盒子模型：css宽度属性就是内容区域的宽度 + padding + border

* CSS的width和height属性除了content区域外，还包含padding和border。
* 一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值）