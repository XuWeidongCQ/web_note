# 一、单向链表

* 在JS中使用多层嵌套的对象来表示链表

* 首先需要一个节点构造函数，来表示链表中的一个元素

* ```js
  class Node {
      constructor(element){
          this.element = element;
          this.next = undefined
      }
  }
  ```

* 其次需要一个链表的构造函数

* ```js
  class LinkList {
      constructor(){
          this.count = 0 //表示链表中元素的个数
          this.head = undefined //指向链表的头部
      };
  }
  ```

* 其中一个指向链表头部的属性是必须的，用于后续进行遍历

* 也可以增加一个属性，用于表示链表的长度，方便后续取出最后一个元素

## 1.1 链表的遍历

* 链表的遍历需要使用一个指针，无限循环直到该指针的下一个元素为undefined为止，首先初始化该指针指向链表的头部

* ```js
  let cur = this.head
  while(cur.next !== undefined){ //遍历到链表的尾部，使得cur指向链表的最后一个元素
    cur.element //cur.element为当前节点的值，可以在这里做一点操作，但是这里取不到最后一个元素
    cur = cur.next
  }
  cur.element //补充最后一个元素
  ```

## 1.2 获取特定位置处的元素

* 初始化一个指针指向链表的头部，然后循环直到该指针指向特定位置的前一个元素位置

```js
getElementAt(index){
  if(index >= 0 && index < this.count){//保证输入的index合法
    let cur = this.head //一个指针指向链表头部
    for(let i=0;i < index && cur !== undefined;i++){//让指针一直遍历到要获取的元素
      cur = cur.next
    }
    return cur
  }
  return undefined
};
```

* 中间的遍历也可以这样写

```js
 let pointer = 0
 while(count <= index){
   if(count === index){
     return cur
   }
   pointer++
   cur = cur.next
 }
```

## 1.3 在链表的任意位置插入元素

* 头部插入单独处理

* 其次，取出要插入位置的前一个元素

* 取出被插入的元素

* 让要插入元素的下一个节点指向被插入的元素

* 让插入位置的前一个元素的下一个节点指向要插入父元素即可

* ```js
  insert(element,index){
    if(index >= 0 && index <= this.count){
      const node = new Node(element);
      if(index === 0){ //在头部插入
        const cur = this.head
        node.next = cur; //将这个插入节点的后续节点指向原来的头部
        this.head = node; //同时头部指向新的
      } else {
        const pervious = this.getElementAt(index-1); //一个指针指向待插入位置的前一个元素
        const cur = pervious.next;//一个指针指向插入位置的元素
        node.next = cur;
        pervious.next = node;
      }
      this.count ++;
      return true
    }
    return false
  };
  ```

## 1.4 统计链表中元素的个数

```js
getSize(){
  let cur = this.head;
  if(cur === null){
    return 0
  }
  let count = 1; //初始化要为1才行
  while(cur.next !== null){
    count++
    cur = cur.next
  }
  return count
}
```

## 1.5 链表和数组的相互转换

* 有些时候将链表转换为数组可以更方便进行处理
* 但是这样会浪费额外的空间

```js
//输入一个链表
const toArr = function(list){
  let pCur = list;
  let arr = [];
  while(pCur){
    arr.push(pCur.val)
    pCur = pCur.next
  }
  return arr
}

//输入一个数组
const toList = function(arr){
  let len = arr.length;
  let node;
  if(len < 1){return null};
  let head = new ListNode(arr[0])
  let pCur = head;
  for(let i=1;i<len;i++){
    node = new ListNode(arr[i])
    pCur.next = node
    pCur = pCur.next
  }
  return head
}
```

# 二、回溯算法

* 回溯算法就是纯暴力穷举，复杂度一般都很高，运行时间较长
* 动态是回溯算法的最优情况
* 所以一般不用于找到问题的所有解，找到满足条件的一个解即可
* 回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作
* 在树上的每一个节点都有一个已经选择的路径和将要做出的下一步选择
* 这种算法一般是递归的



* 可以把回溯函数的输入参数看做是解空间树的节点的属性,问题的答案和递归终止条件也必须在输入参数中

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件: //这是函数的结束条件，这里写解是否满足条件
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```



* 如果只需要找到一个答案只需要在结束条件的时候返回true

```python
def backtrack(路径, 选择列表):
    if 满足结束条件: //这是函数的结束条件，这里写解是否满足条件
        result.add(路径)
        return true

    for 选择 in 选择列表:
        做选择
        if(backtrack(路径, 选择列表))
        		return true
        撤销选择
    return false //如果所有情况都尝试完了还没有满足条件，就只能返回false
```

## 2.1 模板(排列组合算法)

* 这是一个计算无重复数字的所有排列的模板

```js
//selectedPath 传入空数组
//rest 每一步可以选择的列表，这里是需要进行排列的所有数据组成的数组

const backTrack = function(selectedPath,rest,callback){
    if(rest.length === 0){
        if(callback){
            callback(selectedPath.slice(0)) //深复制
        }
        return
    }
    for(let i=0;i<rest.length;i++){
        const chose = rest.splice(i,1)[0]
        selectedPath.push(chose)

        backTrack(selectedPath,rest,callback)

        selectedPath.pop()
        rest.splice(i,0,chose)
    }
}
```

## 2.2 模板(二叉树从根到叶子的每一条路径算法)

```js
//path 默认需要传入根节点的值
//node 传入树
//callback 回调函数
const everyPath = function(path,node,callback){
    if(node.left === null && node.right === null){
        //console.log(path)
        if(callback){
            callback(path.slice(0))
        }
        return
    }
    //构造待选择的列表
    let rest = [];
    rest[0] = node.left ? node.left.key : undefined;
    rest[1] = node.right ? node.right.key : undefined
    for(let i=0;i<rest.length;i++){
        //选择是否合法
        if(rest[i] === undefined){
            continue
        }
        //做出选择
        path.push(rest[i])
        i === 0 ? everyPath(path,node.left,callback) 
                : everyPath(path,node.right,callback)
        //撤销选择
        path.pop()
    }
}
```



# 三、广度优先遍历BFS

* 该算法可以针对图
* 可以把树看成为有向的图
* 还有一个特点是二叉树的子节点最大为2,这可以提前知道

3.1 