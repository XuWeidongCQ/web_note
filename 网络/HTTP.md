# 1 HTTP发展历史

## 1.1 HTTP/0.9

* 相当简单的协议
* 只有一个GET方法，没有首部
* 设计的目标是获取HTML(只有文本，没有图片)
* 工作在80端口
* 规范只有一页

## 1.2 HTTP/1.0

* 于1996年制定和发布
* 规范有60页
* 在0.9版本上新增了大量的内容（如首部、响应码、重定向、错误、更多的请求方法等）
* 缺点
  * 不能多个请求共用一个TCP连接
  * 缺少强制的Host首部
  * 缓存的选择相当简陋

## 1.3 HTTP/1.1

* 1.0版本刚刚制定就发布
* 到目前为止，已使用了20多年
* 改善1.0的不足
  * 强制要求客户端提供Host首部（使得虚拟主机托管成为可能，即一个IP提供多个Web服务）
  * 浏览器不用为每个请求重新发起TCP连接
  * 管道化（允许客户端一次发送所有的请求，但是可能出现队头堵塞影响后续的其他请求）

## 1.4 HTTP/2.0

* 2012年，开始筹备，希望可以：
  * 相比于使用TCP的HTTP/1.1，用户可感知的多数延迟能够量化的显著改善
  * 解决队头堵塞问题
  * 保留1.1版本的语义（方法、状态码）

* 与2015年5月4日发布，成为正式协议

# 2 HTTP报文++

## 2.1 报文结构

<img src="../../../AppData/Roaming/Typora/typora-user-images/image-20200619144516817.png" alt="image-20200619144516817" style="zoom:67%;" />

* 从web客户端发往web服务器的HTTP报文称为请求报文、反之为响应报文，此外没有其他报文。

* 一般结构

  <img src="../../../AppData/Roaming/Typora/typora-user-images/image-20191224111401533.png" alt="image-20191224111401533"  />

![image-20191224111455836](../../../AppData/Roaming/Typora/typora-user-images/image-20191224111455836.png)



* 主要包含两个部分
  * 报文首部
    * 起始行（响应行、请求行。在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况）
    * ==首部字段==（有0个或者多个，为冒号分割的键值对）
  * 报文主体
    * 包含了传输的数据（任意的二进制数据或者文本）
    * 报文主体不一定都有（如get请求没有报文主体）
* 报文主体和实体主体的差异
  * 通常报文主体就是实体主体
  * 只有在传输过程中进行编码操作，实体主体的内容发生了变化（被编码了）才会导致和报文主体的差异



## 2.2 请求方法（常见6种）

* GET
* POST
* PUT
* DELETE
* TRACE -- 查看http请求路线中有没有代理（路由器）修改了发起的HTTP请求，服务器会把最后收到的请求返回
* HEAD -- 和GET类似，只是不像GET请求那样要返回请求的内容，只有响应报文的首部（比如确认一个内容是否存在）
* OPTIONS -- 返回web服务器可以支持的HTTP请求方式

# 3 HTTP状态码++

* 在RFC2616上的状态码共有40种
* 加上扩展就有60余种
* 但是==经常使用的大概只有14种==

## 3.0 1xx 请求已经被接收，需要进一步处理

* 101 Switching Protocols 请求头部若有Upgrade字段，服务器响应101表示可以进行协议的升级，随后将连接转换为升级后的协议(比如升级成websocket)

## 3.1 2XX 成功

表示响应结果被正常处理了

* 200 OK
* 204 No Content 表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分
* 206 Partial Content

## 3.2 3XX 重定向

表明浏览器需要执行某些操作才能让服务器正确地处理请求

* 301 Moved Permanently 永久性重定向++
* 302 Found 临时性重定向++
* 303 See Other
* 304 Not Modified 服务器告诉浏览器的缓存有效，浏览器可以直接使用缓存++
* 305 Temporary Modified 临时性重定向
* 307 请求转发

## 3.3 4XX 客户端错误

表明客户端是发生错误的原因所在

* 400 Bad Request 客户端的请求报文中存在语法错误
* 401 Unauthorized 客户端发送的请求需要进行通过HTTP认证
* 403 Forbidden 客户端请求的内容被服务器拒绝了
* 404 Not Found 客户端请求的内容没有找到
* 405 Method Not Allow web服务器不支持这个HTTP请求方法

## 3.4 5XX 服务器错误

表明服务器本身发生错误

* 500 Internal Server Error 服务器在执行请求的时候发生了错误
* 503 Service Unavailable 服务器处于超负载或者正在停机维护

# 4 Web服务器

* 用单台主机代理多个域名

## 4.1 代理服务器

* 接收到客户端的请求后转发给其他服务器
* 代理不改变请求URI
* 经过代理服务器会附加Via首部字段标记出来请求经过的主机信息

## 4.2 网关

* 和代理的区别就是可以把HTTP请求转化为其他协议通信

## 4.3 隧道

* 可以建立起一条与其他服务器的通信线路，可以使用SSL等加密手段



# 5 HTTP/1.1首部

* HTTP协议的请求和响应报文中必定包含HTTP首部
* 首部内容为客户端和服务端分别处理请求和响应提供所需要的信息
* 对于客户端来说，这些信息中的大部分无须亲自查看

## 5.1 通用首部字段

请求报文和响应报文两方都会使用的首部

* Cache-Control 操作缓存的工作机制
* ==Connection== 控制不再转发给代理的首部字段 管理持久连接
* Date 表明HTTP报文创建的日期和时间
* Pragma 1.1版本之前的遗留字段
* Trailer 说明在报文主体后记录哪些首部字段，常用在分块传输编码的时候
* Transfer-Encoding 规定报文主体传输时候采用的编码方式
* ==Upgrade== 可以用来指定一个完全不同的通信协议
* Via 追踪客户端和服务器之间的传输路径
* Warning 告知用户一些缓存相关的问题的警告

## 5.2 请求首部字段

从客户端向服务器发送请求报文时使用的首部，补充了请求的附加内容、客户端信息、响应内容优先级等信息

* ==Accept== 客户端告诉服务器自己需要的媒体类型
* Accept-Charset  客户端告诉服务器自己支持的字符集
* Accept-Encoding 客户端告诉服务器自己支持的内容编码格式
* Accept-Language 客户端告诉服务器自己支持的语言
* Authorization 客户端告诉服务器自己的证书值
* Expect 客户端告诉服务器自己期待出现的某种特定行为
* From 客户端告诉服务器自己的电子邮件地址
* ==Host== 客户端告诉服务器自己请求的主机名（比如：www.hackr.jp）
* If-Match 带条件的请求—Etag值相关
* If-Modified-Since 带条件的请求++
* If-None-Match 带条件的请求++
* If-Range 带条件的请求
* If-Unmodified-Since 带条件的请求
* Max-Forwards  客户端告诉服务器自己的请求能够被代理转发的次数
* Proxy-Authorization  客户端告诉代理服务器自己的认证信息
* Range  客户端告诉服务器自己获取部分资源的范围
* ==Referer==  客户端告诉服务器自己请求的原始资源的URI
* TE  客户端告诉服务器自己能够处理响应的传输编码的方式
* ==User-Agent==  客户端告诉服务器自己的浏览器的相关的信息

## 5.3 响应首部字段

响应报文使用的首部，补充了相应的附加内容和告诉客户端一些额外的信息

* Accept-Ranges 服务器告诉客户端自己是否能够处理范围请求
* Age  服务器告诉客户端自己的缓存已经存了多长时间
* Etag  服务器告诉客户端实体的标识++
* Location  服务器告诉客户端请求的资源被转移的位置
* Proxy-Authenticate 代理服务器告诉客户端自己所要求的的认证信息
* Retry-After  服务器告诉客户端应该在多久后再次发起请求
* ==Server==  服务器告诉客户端自己所安装的HTTP服务器应用程序的信息  比如：Apache/2.2.17( Unix)
* Vary 源服务器告诉代理服务器相关的缓存控制策略
* ==WWW-Authenticate==  服务器告诉客户端自己所要求的的认证信息

## 5.4 实体首部字段

==针对请求报文和响应报文主体部分==使用的首部

* Allow 通知客户端能够支持的HTTP方法
* Content-Encoding 表明实体主体选用的内容编码格式（对响应主体进行压缩处理的方式，以方便传输）
* Content-Language 表明实体主体选用的自然语言
* Content-Length 表明了实体主体的大小
* Content-Location 表明报文主体对应的URI
* Content-MD5 表明报文主体使用MD5算法后生成的值
* Content-Range 表明目前报文主体所属的范围
* Content-Type 表明报文主体的媒体类型
* Expires 表明资源失效的日期
* Last-Modified 表明资源修改的日期

## 5.5 与Cookie相关的首部字段

这些字段不是HTTP/1.1的标准字段，但是应用很广泛

* Set-Cookie 响应首部，服务器告诉客户端需要保存的信息
  * HttpOnly属性：可以使得Js脚本无法无法获取到Cookie
* Cookie 请求首部，客户端告诉客户端自己本次请求的cookie信息



# 6 确保HTTP通信安全的HTTPS

## 6.1 HTTP通信的缺点

* 通信使用明文，内容可能会被窃听
  * 互联网的线路是大家共同使用的，故存在被窃听的风险
* 不验证通信方的身份，因此有可能遭遇伪装
  * 服务器对所有的客户端的请求都会有响应，有些可能是伪装的客户端
  * 有些可能是伪装的web服务器
* 无法证明报文的完整性，所以报文有可能已遭篡改
  * 报文在传输过程中被中间人拦截并篡改

## 6.2 HTTP+加密+认证+完整性保护 = HTTPS

* 一般在登录界面和购物结算界面使用HTTPS通信

### 6.2.1 公开密钥加密技术

* 加密和解密都会用到密钥

* 加密和解密同用一个密钥的方式称为共享秘钥加密（对称秘钥加密）
* 加密使用一个密钥（公钥），解密使用另一个密钥（私钥）叫做非对称加密

### 6.2.2 实现原理

* HTTPS在应用层和传输层之间加入了SSL(Secure Socket Layer)和TLS(Transport Layer Security)层，而HTTP是没有这一层的
* SSL采用的加密处理方式为公开密钥加密（因为近代所有的加密算法都是公开的，==但是密钥是保密的==）

* 在操作过程中，发送报文的一方使用==对方==的公开密钥进行加密处理（对方会把这个公开密钥给你的），对方收到被加密的报文后，再使用自己的私钥进行解密
* HTTPS采用对称和非对称同时使用的混合加密机制，因为==非对称加密处理速度要慢一些==
  * 首先使用非对称加密将对称加密要使用的同一把密钥传递给双方（保证这个对称加密的密钥不被窃取）
  * 双方拿到对称加密的密钥后使用对称加密技术传递信息

基于此，我们应该怎么确保非对称加密中的公钥是真实存在的，为了解决这个问题，就不得不使用由数字认证机构（CA，Certificate Authority）和其相关机构颁发的公开密钥证书（可以把证书理解为非对称加密中的公钥），操作步骤为：

1. 服务器的运营人员向CA提出要使用公开密钥的申请
2. CA判定申请者身份后，会对申请者要申请的公开密钥进行数字签名，然后将这个公钥和公钥证书绑定在一起后再分配给申请者（意思就是：这个服务器要使用这个公钥进行加密通信，CA颁发一个数字签名证书来证明这件事是真的）
3. 服务器会将这份由CA颁发的公钥证书发送给客户端
4. 客户端使用证书上提到的要使用的公钥验证这个证书的数字签名，验证通过就可以使用这个公钥进行加密传输了（多数浏览器开放商发布版本的时候，会事先在内部植入常用认证机关的公开密钥）
5. 客户端使用这个公钥把自己的报文进行加密处理后发送

以上讨论的证书都是==服务器端的证书==，客户端证书用得比较少，网上银行会使用，这里就不展开了

### 6.2.3 建立HTTPS的过程++

1. 客户端通过发送Client Hello报文开始SSL通信，报文中包含客户端支持的SSL版本，能够使用的加密算法列表和对应的密钥长度等信息 

   [客户端告诉服务器自己支持的加密算法]

   

2. 服务器以Server Hello报文作为回应，同样包括支持的SSL版本，加密算法列表（从客户端的加密算法中进行筛选出来的）

3. 服务器再发送Certificate报文，里面包含公开密钥证书

4. 服务器发送Server Hello Done报文，最初阶段SSL握手阶段结束

   [服务器回应，告诉客户端自己支持的加密算法，把非对称加密的公钥（证书）给客户端]

   

5. 初级握手阶段结束后，客户端以Client Key Exchange报文作为回应，将采用的对称密钥Pre-master secret这个密钥发送给服务器（本次报文已经使用证书中的公开密钥加密了，故不存在这个对称密钥被窃取的风险）

6. 客户端再发送Change Cipher Spec报文，告诉服务器之后的通信都采用Pre-master secret这个密钥进行加密

7. 客户端发送Finished报文，里面包含之间通信内容的整体校验值

   [客户端验证公钥（证书）的合法性，如果不通过，浏览器会提示链接有风险；验证通过就用这个非对称加密的公钥加密对称加密要使用的随机数]

   

8. 服务器发送Change Cipher Spec报文，告诉客户端可以采用Pre-master secret这个密钥进行加密

9. 服务器发送Finished报文

   [服务器利用自己的非对称私钥解密，拿到随机数，以后就可以使用这个随机数进行内容的加密传输]

   

10. 客户端和服务器的Finished报文交换完毕过后，SSL连接建立完成

11. 开始正常的HTTP通信，只是这些HTTP报文会被加密传输

12. 最后由客户端断开SSL连接，客户端发送close_notify报文即可

使用HTTPS技术会比HTTP慢2到100倍，故一般只有在包含个人敏感信息的传输中使用，其他的可以使用HTTP通信，但是随着HTTP2.0的发展，会全部使用HTTPS的。



# 7 确保用户身份的认证机制

## 7.1 为什么要这么做

* 客户端无法判断坐在显示器前面的使用者的身份
* 服务器也不知道通信的另一方是不是想通信的用户

## 7.2 具体措施

### 7.2.1 BASIC认证

* HTTP/1.0内置的认证方式
* 不常用

### 7.2.2 DIGEST认证

* HTTP/1.1中认证方式

### 7.2.3 SSL客户端认证

* 使用HTTPS的客户端证书完成的认证
* 使用费用高
* 操作复杂

### 7.2.4 基于表单认证

* 目前最常见

* 不同的web应用程序有不同的登录界面

* 为了记住登录状态，会使用cookie技术或者token

  

# 8 常见的Web攻击技术

## 8.1 因输出值转义不完全引发的安全漏洞

### 8.1.1 跨站脚本攻击(Cross-Site Scripting，XSS)

* 在动态生成HTML处易发生

### 8.1.2 SQL注入攻击

* 如果url的查询字符串直接与数据库的操作相关联，就易发生

### 8.1.3 OS命令注入攻击

### 8.1.4 HTTP首部注入攻击

## 8.2 因会话管理疏忽引发的安全漏洞

### 8.2.1 会话劫持

### 8.2.2 会话固定攻击

### 8.2.3 跨站请求伪造（Cross-Site Request Forgeries,CSRF）

* 攻击者利用已经设置好的陷阱，拿到已完成认证的用户的认证信息（如sessionId，或者token）

# 9 HTTP缓存++

* 控制浏览器是否开启缓存响应的http响应的头部信息进行控制（使用广泛）或者页面的HTML meta 标签

  ```html
  含义是让浏览器不缓存当前页面
  <META HTTP-EQUIV="Pragma" CONTENT="no-store">
  ```

## 9.1 协商缓存（需要浏览器向服务器确认缓存是否失效）

* 依赖四个字段：Etag(响应字段),Last-Modified(响应字段) --- If-None-Match(请求字段),If-Modified-Since(请求字段)

* 缓存一般用于网页上的图片（带有src的html标签所依赖的资源,比如css,js,图片等文件）
* 如果浏览器中没有相关图片、文件的缓存，就正常发起请求

```txt
step1：
第一次正常发起http请求去请求资源文件 
服务器返回200 同时返回Etag,Last-Modified(这两个用来描述文件)

step2：
第二次请发请求(浏览器刷新)同一个图片，由于浏览器有缓存，浏览器需要向服务器确认缓存是否失效，带上字段If-Modified-Since,If-None-Match(这两个字段的值就是第一次服务器响应Last-Modified和Etag告诉浏览器的值)
如果没有更新，服务器返回304,表示浏览器可以使用缓存的图片
```

<img src="../../../AppData/Roaming/Typora/typora-user-images/image-20200619161856081.png" alt="image-20200619161856081" style="zoom:67%;" />

## 9.2 强制缓存（不需要浏览器向服务器确认缓存是否失效）

* 缓存的有效期需要web服务器自己设定（配置apache服务器的配置文件或者nginx服务器的）

```txt
step1:
第一次正常发起http请求去请求资源文件 
服务器返回200 同时返回Cache-Control或者Expire(Cache-Control的优先级比Expire高)
Expire:取值是一个绝对时间
Cache-Control:max-age=31536000 表示响应31536000秒后过期
Cache-Control:public 表明响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存
Cache-Control:private 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存
Cache-Control:no-cache 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器。
Cache-Control:no-store 禁止浏览器缓存
Cache-Control:must-revalidate 指定如果页面是过期的，则去服务器进行获取
```



<img src="../../../AppData/Roaming/Typora/typora-user-images/image-20200619161919912.png" alt="image-20200619161919912" style="zoom:67%;" />

